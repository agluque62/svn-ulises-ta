//----------------------------------------------------------------------------------------
// patterns & practices - Smart Client Software Factory - Guidance Package
//
// This file was generated by this guidance package as part of the solution template
//
// The ShellApplication class is the entry point for your application. ShellApplication 
// contains the Main method and derives from FormShellApplication base class which is
// provided by the Composite UI Application Block (CAB).
// 
// Note that the RootWorkItem is the default WorkItem provided by CAB.
// 
// It also implements basic exception handling using Enterprise Library Exception
// Handling Application Block.
//
// The shell in this Guidance Package (ShellForm) has a DeckWorkspace called LayoutWorkspace
// The default layout is defined in a separate module called Infrastructure.Layout. This module
// has a usercontorl ShellLayoutView which has a left and right workspace.
//
// For more information see: 
// ms-help://MS.VSCC.v80/MS.VSIPCC.v80/ms.practices.scsf.2007may/SCSF/html/03-01-010-How_to_Create_Smart_Client_Solutions.htm
//
// Latest version of this Guidance Package: http://go.microsoft.com/fwlink/?LinkId=62182
//----------------------------------------------------------------------------------------

using System;
using System.IO;
using System.Windows.Forms;
using HMI.Infrastructure.Library;
using Microsoft.Practices.CompositeUI;
using System.Threading;
using System.Globalization;



namespace HMI.Infrastructure.Shell
{
	/// <summary>
	/// Main application entry point class.
	/// Note that the class derives from CAB supplied base class FormShellApplication, and the 
	/// main form will be ShellForm, also created by default by this solution template
	/// </summary>
	class ShellApplication : SmartClientApplication<WorkItem, ShellForm>
	{
        // [STAThread]
        //static void Main()
        //{
        //    Environment.CurrentDirectory = Path.GetDirectoryName(Application.ExecutablePath);

        //    System.Threading.Thread main = new System.Threading.Thread(MainTh);
        //    main.Start();
        //    main.Join();
        //}
        /// <summary>
        /// 20170720. AGL. Para evitar que se arranque mas de una instancia de la aplicacion.
        /// </summary>
        static string appGuid = "{9275E96B-4750-4818-888C-225F97FDDA69}";

        /// <summary>
        /// Application entry point.
        /// </summary>
        [STAThread]
        static void Main()
        {
            /// 20170720. AGL. Para evitar que se arranque mas de una instancia de la aplicacion.
            using (System.Threading.Mutex mutex = new System.Threading.Mutex(false, "Global\\" + appGuid))
            {
                if (!mutex.WaitOne(0, false))
                {
                    NLog.LogManager.GetLogger("HMI").Fatal("Instance already running...");
                    return;
                }

                Environment.CurrentDirectory = Path.GetDirectoryName(Application.ExecutablePath);
                try
                {
                    CultureInfo.DefaultThreadCurrentCulture = new CultureInfo(Settings.Default.Idioma);
                    CultureInfo.DefaultThreadCurrentUICulture = new CultureInfo(Settings.Default.Idioma);
                }
                catch (CultureNotFoundException exc)
                {
                    CultureInfo.DefaultThreadCurrentCulture = Thread.CurrentThread.CurrentCulture;
                    CultureInfo.DefaultThreadCurrentUICulture = Thread.CurrentThread.CurrentCulture;
                }
                SetThreadPoolSize();
 #if (DEBUG)
                RunInDebugMode();
#else
                RunInReleaseMode();
#endif
                RestoreThreadPoolSize();
            }
        }
        
        private static void RunInDebugMode()
		{
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(AppDomainUnhandledException);
            try
            {
                Application.SetCompatibleTextRenderingDefault(false);
                new ShellApplication().Run();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
		}

		private static void RunInReleaseMode()
		{
			AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(AppDomainUnhandledException);
			Application.SetCompatibleTextRenderingDefault(false);
			try
			{
				new ShellApplication().Run();
			}
			catch (Exception ex)
			{
				HandleException(ex);
			}
		}

		private static void AppDomainUnhandledException(object sender, UnhandledExceptionEventArgs e)
		{
			HandleException(e.ExceptionObject as Exception);
		}

		private static void HandleException(Exception ex)
		{
			if (ex == null)
				return;

            string msg = String.Format("An unhandled exception occurred: <{0}>,\n and the application is terminating. For more information, see your Application event log.", ex.Message);

			MessageBox.Show(msg);
			Application.Exit();
		}

        /** 20180605. Modifica el tamaño del pool de thread para agilizar la creacion de los mismos */
        static int minWorker, minIOC;
        static void SetThreadPoolSize()
        {
            // Get the current settings.
            ThreadPool.GetMinThreads(out minWorker, out minIOC);
            if (ThreadPool.SetMinThreads(20, 20) == false)
            {
                Console.WriteLine("Error en SetMinThreads... Pulse ENTER");
                Console.ReadLine();
            }
        }
        static void RestoreThreadPoolSize()
        {
            if (ThreadPool.SetMinThreads(minWorker, minIOC) == false)
            {
                Console.WriteLine("Error en SetMinThreads... Pulse ENTER");
                Console.ReadLine();
            }
        }
    }
}
