#define _HF_GLOBAL_STATUS_
//----------------------------------------------------------------------------------------
// patterns & practices - Smart Client Software Factory - Guidance Package
//
// This file was generated by the "Add View" recipe.
//
// This class is the concrete implementation of a View in the Model-View-Presenter 
// pattern. Communication between the Presenter and this class is acheived through 
// an interface to facilitate separation and testability.
// Note that the Presenter generated by the same recipe, will automatically be created
// by CAB through [CreateNew] and bidirectional references will be added.
//
// For more information see:
// ms-help://MS.VSCC.v80/MS.VSIPCC.v80/ms.practices.scsf.2007may/SCSF/html/02-09-010-ModelViewPresenter_MVP.htm
//
// Latest version of this Guidance Package: http://go.microsoft.com/fwlink/?LinkId=62182
//----------------------------------------------------------------------------------------

using System;
using System.Drawing;
using System.Diagnostics;
using System.Windows.Forms;
using System.Collections.Generic;
using Microsoft.Practices.CompositeUI;
using Microsoft.Practices.CompositeUI.SmartParts;
using Microsoft.Practices.ObjectBuilder;
using Microsoft.Practices.CompositeUI.EventBroker;
using HMI.Infrastructure.Interface;
using HMI.Model.Module.UI;
using HMI.Model.Module.Services;
using HMI.Model.Module.BusinessEntities;
using HMI.Model.Module.Messages;
using HMI.Presentation.Asecna.Constants;
using HMI.Presentation.Asecna.Properties;
using HMI.Presentation.Asecna.UI;
using Utilities;
using NLog;

namespace HMI.Presentation.Asecna.Views
{
	[SmartPart]
	public partial class RadioView : UserControl
	{
        //VMG Added events for notifying messages
        [EventPublication(EventTopicNames.RdPosPttStateEngine, PublicationScope.Global)]
        public event EventHandler<RangeMsg<PttState>> RdPosPttStateEngine;

        [EventPublication(EventTopicNames.ShowNotifMsgEngine, PublicationScope.Global)]
        public event EventHandler<NotifMsg> ShowNotifMsgEngine;

		struct EstadoAsignacion
		{
			public bool Unavailable;
			public bool _Tx;
			public bool _Rx;
			public RdRxAudioVia _AudioVia;
		};

		private static Logger _Logger = LogManager.GetCurrentClassLogger();

		private IModelCmdManagerService _CmdManager = null;
		private StateManagerService _StateManager = null;
		private List<RdButton> _RdButtons = new List<RdButton>();
		private Dictionary<RdButton, Image> _PttBlinkList = null;
		private Dictionary<RdButton, Image> _SquelchBlinkList = null;
		private Dictionary<RdButton, Color> _RtxBlinkList = null;
        private Dictionary<RdButton, RdDst> _PttPushedList = null;
		private bool _PttBlinkOn = true;
		private bool _SquelchBlinkOn = true;
		private bool _RtxBlinkOn = true;
		private int _NumPositionsByPage;
        private bool _CarrierDetectionEventFired = false;
        private bool _TxErrorEventFired = false;
        private List<EstadoAsignacion> _EstadosAsignacion = new List<EstadoAsignacion>();
#if _HF_GLOBAL_STATUS_
        private string _HfGlobalStatus = "";
#endif
        

		private bool _RdSpeakerEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative; }
		}
		private bool _RdHeadPhonesEnabled
		{
            get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !_StateManager.Tlf.SoloAltavoces; }
		}
		private bool _PttEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative; }
		}
		private bool _RtxEnabled
		{
			get
			{
				return _StateManager.Tft.Enabled && _StateManager.Engine.Operative && 
					!_StateManager.Radio.PttOn &&
					(_StateManager.Radio.GetNumFrAvalilablesForRtx(_RdPageBT.Page * _NumPositionsByPage, _NumPositionsByPage) > 1);
			}
		}

        private string _Rtx // Miguel
        {
            get { return Resources.Rtx; }
        }       
		private bool _RdPageEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !_StateManager.Radio.PttOn; }
		}

        public RadioView([ServiceDependency] IModelCmdManagerService cmdManager, [ServiceDependency] StateManagerService stateManager)
		{
			InitializeComponent();
            _SelCallWS.Name = WorkspaceNames.SelCallWorkspace;

			_CmdManager = cmdManager;
			_StateManager = stateManager;

			_RdButtonsTLP.RowCount = Settings.Default.RdRows;
			_RdButtonsTLP.RowStyles.Clear();

			for (int i = 0; i < _RdButtonsTLP.RowCount; i++)
			{
				RowStyle st = new RowStyle(SizeType.Percent, 100);
				_RdButtonsTLP.RowStyles.Add(st);
			}

			_RdButtonsTLP.ColumnCount = Settings.Default.RdColumns;
			_RdButtonsTLP.ColumnStyles.Clear();

			for (int i = 0; i < _RdButtonsTLP.ColumnCount; i++)
			{
				ColumnStyle st = new ColumnStyle(SizeType.Percent, 100);
				_RdButtonsTLP.ColumnStyles.Add(st);
			}

			_NumPositionsByPage = _RdButtonsTLP.RowCount * _RdButtonsTLP.ColumnCount;
            /** 20180425. RSR */
            _StateManager.Radio.PageSize = _NumPositionsByPage;
            
            _PttBlinkList = new Dictionary<RdButton, Image>();
			_SquelchBlinkList = new Dictionary<RdButton, Image>();
			_RtxBlinkList = new Dictionary<RdButton, Color>();
            _PttPushedList = new Dictionary<RdButton, RdDst>();
 
			for (int row = 0, pos = 0; row < _RdButtonsTLP.RowCount; row++)
			{
				for (int column = 0; column < _RdButtonsTLP.ColumnCount; column++, pos++)
				{
					RdButton bt = new RdButton();
					_RdButtonsTLP.Controls.Add(bt, column, row);
					_RdButtons.Add(bt);
					_EstadosAsignacion.Add(new EstadoAsignacion());

					bt.Dock = DockStyle.Fill;
					bt.Name = "_RdButton" + pos;
					bt.Visible = false;
					bt.Id = pos;

					bt.Click += RdButton_Click;
					bt.TxClick += RdButton_TxClick;
					bt.RxLongClick += RdButton_RxLongClick;
					bt.RxShortClick += RdButton_RxShortClick;
				}
			}

			_RdSpeakerUDB.Level = _StateManager.RdSpeaker.Level;
            _RdHfSpeakerUDB.Level = _StateManager.HfSpeaker.Level;
            //En Asecna el doble altavoz está siempre para frecuencias HF o para todas
            _RdHfSpeakerUDB.Enabled = _RdSpeakerUDB.Enabled = _RdSpeakerEnabled;
            _RdHfSpeakerUDB.DrawX = _RdSpeakerUDB.DrawX = true;
            _RdHeadPhonesUDB.Visible = !_StateManager.Tlf.SoloAltavoces;
            _RdHeadPhonesUDB.Level = _StateManager.RdHeadPhones.Level;
			_RdHeadPhonesUDB.Enabled = _RdHeadPhonesEnabled;
			_PttBT.Enabled = _PttEnabled;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;
            _RtxBT.Text = _Rtx; // Miguel

            RecuperaEstadoAsignacionFrecuencias();            
		}

		[EventSubscription(EventTopicNames.TftEnabledChanged, ThreadOption.Publisher)]
		[EventSubscription(EventTopicNames.EngineStateChanged, ThreadOption.Publisher)]
		public void OnTftEngineChanged(object sender, EventArgs e)
		{
            _RdHfSpeakerUDB.Enabled = _RdSpeakerUDB.Enabled = _RdSpeakerEnabled;
			_RdHeadPhonesUDB.Enabled = _RdHeadPhonesEnabled;
			_PttBT.Enabled = _PttEnabled;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;

			foreach (RdButton bt in _RdButtons)
			{
				bt.Enabled = _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !_StateManager.Radio[bt.Id].Unavailable;
			}
		}

        [EventSubscription(EventTopicNames.RdSpeakerLevelChanged, ThreadOption.Publisher)]
        public void OnRdSpeakerLevelChanged(object sender, EventArgs e)
        {
            _RdSpeakerUDB.Level = _StateManager.RdSpeaker.Level;
        }

        [EventSubscription(EventTopicNames.RdHfSpeakerLevelChanged, ThreadOption.Publisher)]
        public void OnRdHFSpeakerLevelChanged(object sender, EventArgs e)
        {
            _RdHfSpeakerUDB.Level = _StateManager.HfSpeaker.Level;
        }

        [EventSubscription(EventTopicNames.RdHeadPhonesLevelChanged, ThreadOption.Publisher)]
		public void OnRdHeadPhonesLevelChanged(object sender, EventArgs e)
		{
			_RdHeadPhonesUDB.Level = _StateManager.RdHeadPhones.Level;
		}

        /* VMG 06/08/2018 */
        ///<summary>
        /// Evento producido en el cambio de estado del Ptt On/Off.
        ///</summary>
		[EventSubscription(EventTopicNames.PttOnChanged, ThreadOption.Publisher)]
		public void OnPttOnChanged(object sender, EventArgs e)
		{
            //Control de errores para CarrierDetection y para TxConfirmation
            if (_StateManager.Radio.PttOn)
            {
                if (Settings.Default.TxConfirmationDetectionTimeOut < 10)
                    this._TxConfirmationDetectionTimer.Enabled = false;
                else
                {
                    this._TxConfirmationDetectionTimer.Enabled = true;
                    this._TxConfirmationDetectionTimer.Interval = Settings.Default.TxConfirmationDetectionTimeOut;
                }
                if (Settings.Default.CarrierDetectionTimeOut < 10)
                    this._CarrierDetectionTimer.Enabled = false;
                else
                {
                    this._CarrierDetectionTimer.Enabled = true;
                    this._CarrierDetectionTimer.Interval = Settings.Default.CarrierDetectionTimeOut;
                }
            }
            else
            {//Liberar del estado de error los que tengan fallo al soltar el Ptt
                _TxConfirmationDetectionTimer.Enabled = false;
                _CarrierDetectionTimer.Enabled = false;
                _CarrierDetectionEventFired = false;
                _TxErrorEventFired = false;

                /* VMG 04/09/2018 */
                //Con esto hacemos que una vez que se ha dado el error de transmision, 
                // al dejar de recibir PTT o dejar de pulsar el boton, se genera un estado NoPtt
                // que hace que el boton vuelva al estado normal seleccionado (color verde presumiblemente)
                var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
                foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
                {
                    if (p.Value.Ptt != PttState.PttOnlyPort && p.Value.Ptt != PttState.PttPortAndMod
                        && p.Value.Ptt != PttState.ExternPtt)
                    {
                        try
                        {
                            General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.NoPtt));
                        }
                        catch (Exception ex)
                        {
                            _Logger.Error("ERROR generando evento PTT.NoPtt. " + ex);
                        }
                    }
                }
            }
			_PttBT.ButtonColor = _StateManager.Radio.PttOn ? VisualStyle.Colors.Blue : VisualStyle.ButtonColor;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;
		}

		[EventSubscription(EventTopicNames.RtxChanged, ThreadOption.Publisher)]
		public void OnRtxChanged(object sender, EventArgs e)
		{
			if (_StateManager.Radio.Rtx > 0)
			{
				_RtxBT.Text = "Rtx " + (char)('G' + _StateManager.Radio.Rtx - 1);
				_RtxBT.ButtonColor = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;
				_RtxBlinkTimer.Enabled = true;
			}
			else
			{
				_RtxBlinkTimer.Enabled = false;
				_RtxBlinkOn = true;
				_RtxBT.Text = "Rtx";
				_RtxBT.ButtonColor = VisualStyle.ButtonColor;
			}

			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = 0; i < _NumPositionsByPage; i++)
			{
				RdButton bt = _RdButtons[i];
				RdDst dst = _StateManager.Radio[i + absPageBegin];

				Reset(bt, dst);
			}
		}

		[EventSubscription(EventTopicNames.RdPageChanged, ThreadOption.Publisher)]
		public void OnRdPageChanged(object sender, EventArgs e)
		{
			_RdPageBT.Page = _StateManager.Radio.Page;
			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = 0; i < _NumPositionsByPage; i++)
			{
				RdButton bt = _RdButtons[i];
				RdDst dst = _StateManager.Radio[i + absPageBegin];

				Reset(bt, dst);
			}
		}

		[EventSubscription(EventTopicNames.RadioChanged, ThreadOption.Publisher)]
		public void OnRadioChanged(object sender, RangeMsg e)
		{
			Debug.Assert(e.Count > 0);
			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

            _Logger.Debug("******** M+N [RadioView::OnRadioChanged]");

			for (int i = Math.Max(e.From, absPageBegin), to = Math.Min(e.From + e.Count, absPageBegin + _NumPositionsByPage); i < to; i++)
			{
				RdButton bt = _RdButtons[i - absPageBegin];
				RdDst dst = _StateManager.Radio[i];
				EstadoAsignacion estado = _EstadosAsignacion[i - absPageBegin];
				Reset(bt, dst, ref estado);
				//Reset(bt, dst);
				_EstadosAsignacion[i - absPageBegin] = estado;

                if (i < Settings.Default.AssignatedStates.Count)
                {
                    Settings.Default.AssignatedStates.RemoveAt(i - absPageBegin);
                    Settings.Default.AssignatedStates.Insert(i - absPageBegin, dst.Frecuency + "," + _EstadosAsignacion[i - absPageBegin]._Rx.ToString() + "," +
                                                        ((dst.TipoFrecuencia == TipoFrecuencia_t.HF) ? false : _EstadosAsignacion[i - absPageBegin]._Tx) +
                                                            "," + _EstadosAsignacion[i - absPageBegin]._AudioVia + "," + _EstadosAsignacion[i - absPageBegin].Unavailable);
                }
                else
                {
                    Settings.Default.AssignatedStates.Add(dst.Frecuency + "," + _EstadosAsignacion[i - absPageBegin]._Rx.ToString() + "," +
                                                        ((dst.TipoFrecuencia == TipoFrecuencia_t.HF) ? false : _EstadosAsignacion[i - absPageBegin]._Tx) +
                                                            "," + _EstadosAsignacion[i - absPageBegin]._AudioVia + "," + _EstadosAsignacion[i - absPageBegin].Unavailable);
                }
			}

			Settings.Default.Save();

			_RtxBT.Enabled = _RtxEnabled;
		}

		[EventSubscription(EventTopicNames.TitleIdChanged, ThreadOption.Publisher)]
		public void OnTitleIdChanged(object sender, EventArgs e)
		{
			if (Settings.Default.Sector != _StateManager.Title.Id)
			{
				int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

				for (int i = absPageBegin, to = absPageBegin + _NumPositionsByPage; i < to; i++)
				{
					RdButton bt = _RdButtons[i - absPageBegin];
					if (!_StateManager.Radio[i].Unavailable && _StateManager.Radio[i].Rx)
					{
						RdButton_RxLongClick(bt, null);
					}
				}

				Settings.Default.Sector = _StateManager.Title.Id;
				Settings.Default.Save();
			}
		}

#if _HF_GLOBAL_STATUS_

        [EventSubscription(EventTopicNames.HfGlobalStatus, ThreadOption.Publisher)]
        public void OnHfGlobalStatus(object sender, StateMsg<string> msg)
        {
            if (msg.State != _HfGlobalStatus)
            {
                _HfGlobalStatus = msg.State;

                _RdPageBT.Page = _StateManager.Radio.Page;
                int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

                for (int i = 0; i < _NumPositionsByPage; i++)
                {
                    RdButton bt = _RdButtons[i];
                    RdDst dst = _StateManager.Radio[i + absPageBegin];

                    UpdateTx(bt, dst);
                }
            }
        }
        /// <summary>
        /// Actualiza el estado habilitado o no del tx del botón, según el estado global Hf
        /// Se llama en los reset generales y en los cambios del estado global Hf
        /// Si la frecuencia no es HF, el TX está siempre habilitado (caso cambio destino en sectorizaciones)
        /// </summary>
        /// <param name="bt" botón sobre el que se actualiza></param>
        /// <param name="dst" destino al que corresponde el botón></param>
        private void UpdateTx(RdButton bt, RdDst dst)
        {
                    if (dst.TipoFrecuencia == TipoFrecuencia_t.HF)
                    {
                switch (_HfGlobalStatus)
                        {
                    case "DISC":
                            if (dst.Tx)
                                // Quitarlo de transimisión, ya que el gestor de HF no esta disponible
                                _CmdManager.RdForceTxOff(bt.Id);
                            bt.EnableTx(false);
                        break;
                    case "NODISP":
                            // Sólo las frecuencias HF que no están ya asignadas en TX se deben de inhabilitar
                            if (!dst.Tx)
                                bt.EnableTx(false);
                        break;
                    case "DISP":
                        bt.EnableTx(true);
                        break;
                    default:
                        _Logger.Warn("Unknown _HfGlobalStatus {0}", _HfGlobalStatus);
                        break;
                        }
            }
                        else
                            bt.EnableTx(true);
                        }

#endif
        /// <summary>
        /// Este evento llega cuando hay un cambio en la presencia del altavoz
        /// se usa para pintar el aspa en su control
        /// </summary>
        /// <param name="sender">no se usa</param>
        /// <param name="e">no se usa</param>
        [EventSubscription(EventTopicNames.SpeakerChanged, ThreadOption.Publisher)]
        public void OnSpeakerChanged(object sender, EventArgs e)
        {
            if (sender.GetType() == typeof(RdSpeaker))
            {
                if (_StateManager.RdSpeaker.Presencia == false)
                {
                    _RdSpeakerUDB.DrawX = true;
                }
                else
                {
                    _RdSpeakerUDB.DrawX = false;
                }
            }
            else if (sender.GetType() == typeof(HfSpeaker))
            {
                if (_StateManager.HfSpeaker.Presencia == false)
                {
                    _RdHfSpeakerUDB.DrawX = true;
                }
                else
                {
                    _RdHfSpeakerUDB.DrawX = false;
                }
            }
        }

        /* VMG 05/09/2018 */
        ///<summary>
        /// Error al confirmar la Transmision. Tick del Timer.
        ///</summary>
        private void _TxConfirmationDetectionTimer_Tick(object sender, EventArgs e)
        {
            try
            {
                if (_TxConfirmationDetectionTimer.Enabled)
                {
                    var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
                    foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
                    {
                        if (p.Value.Ptt != PttState.PttOnlyPort && p.Value.Ptt != PttState.PttPortAndMod
                            && p.Value.Ptt != PttState.ExternPtt)
                        {
                            General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.TxError));
                            _TxErrorEventFired = true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR generando timer error recepcion Tx", ex);
            }
        }

        /* VMG 05/09/2018 */
        ///<summary>
        /// Error de Rx al realizar Tx. Tick del Timer.
        ///</summary>
        private void _CarrierDetectionTimer_Tick(object sender, EventArgs e)
        {
            try
            {
                if (_CarrierDetectionTimer.Enabled)
                {
                    var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
                    foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
                    {
                        if (p.Value.Ptt == PttState.PttOnlyPort && p.Value.Squelch == SquelchState.NoSquelch)
                        {
                            General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.CarrierError));
                            _CarrierDetectionEventFired = true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR generando timer Ptt", ex);
            }
        }

		private void RecuperaEstadoAsignacionFrecuencias()
		{
			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = absPageBegin, to = absPageBegin + _NumPositionsByPage; i < to; i++)
			{
				if (i < Settings.Default.AssignatedStates.Count)
				{
					string[] estado = Settings.Default.AssignatedStates[i].Split(',');

					EstadoAsignacion eAsignacion = new EstadoAsignacion();

					eAsignacion._Rx = estado[1] == "True";
					eAsignacion._Tx = estado[2] == "True";
					switch (estado[3])
					{
                        case "HfSpeaker":
                            eAsignacion._AudioVia = RdRxAudioVia.HfSpeaker;
                            break;
                        case "HeadPhones":
                            eAsignacion._AudioVia = RdRxAudioVia.HeadPhones;
                            break;
                        case "Speaker":
							eAsignacion._AudioVia = RdRxAudioVia.Speaker;
							break;
						case "NoAudio":
							eAsignacion._AudioVia = RdRxAudioVia.NoAudio;
							break;
					}

					_EstadosAsignacion[i - absPageBegin] = eAsignacion;
				}
			}
		}

		private void Reset(RdButton bt, RdDst dst, ref EstadoAsignacion estado)
		{
			Reset(bt, dst);

            if (!dst.Unavailable && estado.Unavailable && !_StateManager.ScreenSaver.On)
			{
				if (estado._Rx && !dst.Rx)
				{
					RdButton_RxShortClick(bt, null);
				}
				else if (estado._AudioVia==RdRxAudioVia.HeadPhones)
				{
                    if (dst.TipoFrecuencia == TipoFrecuencia_t.HF && (dst.AudioVia == RdRxAudioVia.HfSpeaker || dst.AudioVia == RdRxAudioVia.Speaker))
					    RdButton_RxShortClick(bt, null);
                    else if (dst.TipoFrecuencia != TipoFrecuencia_t.HF && dst.AudioVia == RdRxAudioVia.Speaker)
                        RdButton_RxShortClick(bt, null);
				}
                else if (estado._AudioVia == RdRxAudioVia.HfSpeaker && dst.AudioVia == RdRxAudioVia.Speaker)
                {
                    RdButton_RxShortClick(bt, null);
                }

                if (estado._Tx && !dst.Tx)
                {
                    //RdButton_TxClick(bt, null);
                    try
                    {
                        // Forzar la asignación de Tx independientemente de si está ya asignada en otra posición
                        _CmdManager.RdConfirmTxState(bt.Id);
                    }
                    catch (Exception ex)
                    {
                        int pos = _RdButtons.IndexOf(bt);
                        string msg = string.Format("ERROR modificando Tx de frecuencia RD [Pos={0}] [Id={1}]", pos, bt.Id);
                        _Logger.Error(msg, ex);
                    }
                }
			}
			else if (!dst.Unavailable && !estado.Unavailable)
			{
				estado._Tx = dst.Tx;
				estado._Rx = dst.Rx;
				estado._AudioVia = dst.AudioVia;
			}

			estado.Unavailable = dst.Unavailable ||
								estado._Rx != dst.Rx ||
								estado._Tx != dst.Tx ||
								estado._AudioVia != dst.AudioVia;
		}

		private void Reset(RdButton bt, RdDst dst)
		{
			bt.Id = dst.Id;

			if (_PttBlinkList.Remove(bt) && (_PttBlinkList.Count == 0))
			{
				_PttBlinkTimer.Enabled = false;
				_PttBlinkOn = true;
			}
			if (_SquelchBlinkList.Remove(bt) && (_SquelchBlinkList.Count == 0))
			{
				_SquelchBlinkTimer.Enabled = false;
				_SquelchBlinkOn = true;
			}
			_RtxBlinkList.Remove(bt);
            _PttPushedList.Remove(bt);

			if (dst.IsConfigurated)
			{
				Color title = VisualStyle.ButtonColor;
				Color tx = VisualStyle.ButtonColor;
				Color rx = VisualStyle.ButtonColor;
				Color txForeColor = VisualStyle.Colors.White;
				Color rxForeColor = VisualStyle.Colors.White;
				Image ptt = null;
				Image squelch = null;
				Image audio = null;
				int rtxGroup = 0;
				bool allAsOneBt = false;

				if (!dst.Unavailable)
				{
					rtxGroup = dst.RtxGroup;

					if (dst.Rx)
					{
						title = rx = VisualStyle.Colors.White;
						rxForeColor = VisualStyle.Colors.Green;

						if (dst.Tx)
						{
							tx = VisualStyle.Colors.White;
							txForeColor = VisualStyle.Colors.Green;
                            _PttPushedList[bt] = dst;//VMG lista con los botones seleccionados en la UI

							if (_StateManager.Radio.Rtx > 0)
							{
                                rtxGroup = dst.RtxGroup < 0 ? dst.RtxGroup : dst.TempRtxGroup;

								if (rtxGroup == 0)
								{
									allAsOneBt = true;
									title = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;
									_RtxBlinkList[bt] = VisualStyle.Colors.Yellow;
								}
								else if (rtxGroup == _StateManager.Radio.Rtx)
								{
									allAsOneBt = true;
									title = VisualStyle.Colors.Yellow;
								}
							}
						}
					}

                    NotifMsg msg = null;
					switch (dst.Ptt)
					{
                        case PttState.NoPtt:
                            break;
						case PttState.ExternPtt:
						case PttState.PttOnlyPort:
							ptt = Resources.Ptt;
							break;
						case PttState.PttPortAndMod:
							ptt = _PttBlinkOn ? Resources.Ptt : null;
							_PttBlinkList[bt] = Resources.Ptt;
							_PttBlinkTimer.Enabled = true;
							break;
						case PttState.Blocked:
							ptt = Resources.PttBlocked;
							break;
                        //VMG 04/09/2018 Cambios en los estados
                        case PttState.Error://Error en portadora
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.CarrierDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                            General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            break;
                        //VMG 05/09/2018 Cambios en los estados
                        case PttState.CarrierError://Error en portadora
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            if (!_CarrierDetectionEventFired && !_TxErrorEventFired)
                            {//Lanzamos el mensaje solo una vez
                                msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.CarrierDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                                General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            }
                            break;
                        case PttState.TxError://Error en la confirmacion de la Tx
                            // PttState.PttNotConfirmed 
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            if (!_TxErrorEventFired && !_CarrierDetectionEventFired)
                            {//Lanzamos el mensaje solo una vez
                                msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.TxConfirmationDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                                General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            }
                            break;
                        /*default://Error en la confirmacion de la Tx lo capturamos como PttState.NoPtt
                            // PttState.PttNotConfirmed 
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            NotifMsg msg2 = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.TxConfirmationDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                            General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg2);
                            break;*/
					}

					switch (dst.Squelch)
					{
						case SquelchState.SquelchOnlyPort:
							squelch = Resources.Squelch;
							break;
						case SquelchState.SquelchPortAndMod:
							squelch = _SquelchBlinkOn ? Resources.Squelch : null;
							_SquelchBlinkList[bt] = Resources.Squelch;
							_SquelchBlinkTimer.Enabled = true;
							break;
					}

					switch (dst.AudioVia)
					{
						case RdRxAudioVia.Speaker:
                            if (_StateManager.Radio.DoubleRadioSpeaker)
                                audio = Resources.SpeakerUp;
                            else
							    audio = Resources.RxSpeaker;
							break;
						case RdRxAudioVia.HeadPhones:
							audio = Resources.RxHeadPhones;
							break;
                        case RdRxAudioVia.HfSpeaker:
                            if (_StateManager.Radio.DoubleRadioSpeaker)
                                audio = Resources.HFSpeakerUp;
                            else
                                audio = Resources.HfSpeaker;
                            break;
					}
				}

                bt.Reset(dst.Frecuency, dst.Alias, dst.Unavailable, allAsOneBt, rtxGroup, ptt, squelch, audio, title, tx, rx, txForeColor, rxForeColor, dst.TipoFrecuencia == TipoFrecuencia_t.HF ? VisualStyle.Colors.HfColor : VisualStyle.Colors.Black);
				bt.Enabled = _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !dst.Unavailable;
                UpdateTx(bt, dst);
			}

			bt.Visible = dst.IsConfigurated;
		}

        private void _RdSpeakerUDB_LevelDown(object sender, EventArgs e)
        {
            int level = _RdSpeakerUDB.Level - 1;

            try
            {
                _CmdManager.RdSetSpeakerLevel(level);
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR bajando el nivel del altavoz RD a " + level, ex);
            }
        }

        private void _RdSpeakerUDB_LevelUp(object sender, EventArgs e)
        {
            int level = _RdSpeakerUDB.Level + 1;

            try
            {
                _CmdManager.RdSetSpeakerLevel(level);
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR subiendo el nivel del altavoz RD a " + level, ex);
            }
        }

        private void _HfSpeakerUDB_LevelDown(object sender, EventArgs e)
        {
            int level = _RdHfSpeakerUDB.Level - 1;

            try
            {
                _CmdManager.RdSetHfSpeakerLevel(level);
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR bajando el nivel del altavoz HF a " + level, ex);
            }
        }

        private void _HfSpeakerUDB_LevelUp(object sender, EventArgs e)
        {
            int level = _RdHfSpeakerUDB.Level + 1;

            try
            {
                _CmdManager.RdSetHfSpeakerLevel(level);
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR subiendo el nivel del altavoz HF a " + level, ex);
            }
        }

        private void _RdHeadPhonesUDB_LevelDown(object sender, EventArgs e)
		{
            int level = _RdHeadPhonesUDB.Level - 1;

			try
			{
				_CmdManager.RdSetHeadPhonesLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR bajando el nivel de los microcascos RD a " + level, ex);
			}
		}

		private void _RdHeadPhonesUDB_LevelUp(object sender, EventArgs e)
		{
			int level = _RdHeadPhonesUDB.Level + 1;

			try
			{
				_CmdManager.RdSetHeadPhonesLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR subiendo el nivel de los microcascos RD a " + level, ex);
			}
		}

		private void _RtxBT_Click(object sender, EventArgs e)
		{
			try
			{
				_CmdManager.RdRtxClick(_NumPositionsByPage);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR iniciando operacion Rtx", ex);
			}
		}

		private void _PttBT_MouseDown(object sender, MouseEventArgs e)
		{
			try
			{
				_CmdManager.RdSetPtt(true);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR pulsando boton de Ptt", ex);
			}
		}

		private void _PttBT_MouseUp(object sender, MouseEventArgs e)
		{
			try
			{
				_CmdManager.RdSetPtt(false);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR liberando boton de Ptt", ex);
			}
		}

		private void _RdPageBT_UpClick(object sender)
		{
			int actualPage = _RdPageBT.Page;

			try
			{
				_CmdManager.RdLoadNextPage(actualPage, _NumPositionsByPage);
			}
			catch (Exception ex)
			{
				string msg = string.Format("ERROR solicitando pagina RD siguiente [Actual={0}]", actualPage);
				_Logger.Error(msg, ex);
			}
		}

		private void _RdPageBT_DownClick(object sender)
		{
			int actualPage = _RdPageBT.Page;

			try
			{
				_CmdManager.RdLoadPrevPage(actualPage, _NumPositionsByPage);
			}
			catch (Exception ex)
			{
				string msg = string.Format("ERROR solicitando pagina RD previa [Actual={0}]", actualPage);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_Click(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchRtxState(id);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando pertenencia a grupo Rtx de frecuencia RD [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_TxClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchTxState(id);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Tx de frecuencia RD [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_RxLongClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchRxState(id, true);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Rx de frecuencia RD mediante pulsacion larga [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_RxShortClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchRxState(id, false);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Rx de frecuencia RD mediante pulsacion corta [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void _PttBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_PttBlinkTimer.Enabled)
				{
					_PttBlinkOn = !_PttBlinkOn;
					foreach (KeyValuePair<RdButton, Image> p in _PttBlinkList)
					{
						p.Key.PttImage = _PttBlinkOn ? p.Value : null;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Ptt", ex);
			}
		}

		private void _SquelchBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_SquelchBlinkTimer.Enabled)
				{
					_SquelchBlinkOn = !_SquelchBlinkOn;
					foreach (KeyValuePair<RdButton, Image> p in _SquelchBlinkList)
					{
						p.Key.SquelchImage = _SquelchBlinkOn ? p.Value : null;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Squelch", ex);
			}
		}

		private void _RtxBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_RtxBlinkTimer.Enabled)
				{
					_RtxBlinkOn = !_RtxBlinkOn;
					_RtxBT.ButtonColor = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;

					foreach (KeyValuePair<RdButton, Color> p in _RtxBlinkList)
					{
						p.Key.TitleBackColor = _RtxBlinkOn ? p.Value : VisualStyle.ButtonColor;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Rtx", ex);
			}
		}

		private void RadioView_BackColorChanged(object sender, EventArgs e)
		{
			Invalidate(true);
		}
	}
}

