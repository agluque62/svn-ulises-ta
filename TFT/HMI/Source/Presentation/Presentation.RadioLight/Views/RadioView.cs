//----------------------------------------------------------------------------------------
// patterns & practices - Smart Client Software Factory - Guidance Package
//
// This file was generated by the "Add View" recipe.
//
// This class is the concrete implementation of a View in the Model-View-Presenter 
// pattern. Communication between the Presenter and this class is acheived through 
// an interface to facilitate separation and testability.
// Note that the Presenter generated by the same recipe, will automatically be created
// by CAB through [CreateNew] and bidirectional references will be added.
//
// For more information see:
// ms-help://MS.VSCC.v80/MS.VSIPCC.v80/ms.practices.scsf.2007may/SCSF/html/02-09-010-ModelViewPresenter_MVP.htm
//
// Latest version of this Guidance Package: http://go.microsoft.com/fwlink/?LinkId=62182
//----------------------------------------------------------------------------------------

using System;
using System.Drawing;
using System.Diagnostics;
using System.Windows.Forms;
using System.Collections.Generic;
using Microsoft.Practices.CompositeUI;
using Microsoft.Practices.CompositeUI.SmartParts;
using Microsoft.Practices.ObjectBuilder;
using Microsoft.Practices.CompositeUI.EventBroker;
using HMI.Infrastructure.Interface;
using HMI.Model.Module.UI;
using HMI.Model.Module.Services;
using HMI.Model.Module.BusinessEntities;
using HMI.Model.Module.Messages;
using HMI.Presentation.RadioLight.Constants;
using HMI.Presentation.RadioLight.Properties;
using HMI.Presentation.RadioLight.UI;
using Utilities;
using NLog;

namespace HMI.Presentation.RadioLight.Views
{
	[SmartPart]
	public partial class RadioView : UserControl
	{
        //VMG Added events for notifying messages
        [EventPublication(EventTopicNames.RdPosPttStateEngine, PublicationScope.Global)]
        public event EventHandler<RangeMsg<PttState>> RdPosPttStateEngine;
        
        [EventPublication(EventTopicNames.ShowNotifMsgEngine, PublicationScope.Global)]
        public event EventHandler<NotifMsg> ShowNotifMsgEngine;

		struct EstadoAsignacion
		{
			public bool Unavailable;
			public bool _Tx;
			public bool _Rx;
			public RdRxAudioVia _AudioVia;
		};

		private static Logger _Logger = LogManager.GetCurrentClassLogger();

		private IModelCmdManagerService _CmdManager = null;
		private StateManagerService _StateManager = null;
		private List<RdButton> _RdButtons = new List<RdButton>();
		private Dictionary<RdButton, Image> _PttBlinkList = null;
		private Dictionary<RdButton, Image> _SquelchBlinkList = null;
		private Dictionary<RdButton, Color> _RtxBlinkList = null;
        private Dictionary<RdButton, RdDst> _PttPushedList = null;
		private bool _PttBlinkOn = true;
		private bool _SquelchBlinkOn = true;
		private bool _RtxBlinkOn = true;
        private int _NumPositionsByPage;
        private bool _CarrierDetectionEventFired = false;
        private bool _TxErrorEventFired = false;
        private List<EstadoAsignacion> _EstadosAsignacion = new List<EstadoAsignacion>();

		private bool _RdSpeakerEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative; }
		}
        //En Twr el doble altavoz solo si está configurado
        private bool _HfSpeakerEnabled
        {
            get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative && _StateManager.Radio.DoubleRadioSpeaker; }
        }
        private bool _RdHeadPhonesEnabled
		{
            get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !_StateManager.Tlf.SoloAltavoces; }
		}
		private bool _PttEnabled
		{
            get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative; }
        }
        private bool _RtxEnabled
		{
            get
            {
                return _StateManager.Tft.Enabled && _StateManager.Engine.Operative &&
                    !_StateManager.Radio.PttOn &&
                    (_StateManager.Radio.GetNumFrAvalilablesForRtx(_RdPageBT.Page * _NumPositionsByPage, _NumPositionsByPage) > 1);
            }
        }
        private bool _RdPageEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !_StateManager.Radio.PttOn; }
        }
        private string _Rtx // Miguel
        {
            get { return Resources.Rtx; }
        }
		public RadioView([ServiceDependency] IModelCmdManagerService cmdManager, [ServiceDependency] StateManagerService stateManager)
		{
			InitializeComponent();

            _CmdManager = cmdManager;
			_StateManager = stateManager;

			_RdButtonsTLP.RowCount = Settings.Default.RdRows;
			_RdButtonsTLP.RowStyles.Clear();

			for (int i = 0; i < _RdButtonsTLP.RowCount; i++)
			{
				RowStyle st = new RowStyle(SizeType.Percent, 100);
				_RdButtonsTLP.RowStyles.Add(st);
			}

			_RdButtonsTLP.ColumnCount = Settings.Default.RdColumns;
			_RdButtonsTLP.ColumnStyles.Clear();

			for (int i = 0; i < _RdButtonsTLP.ColumnCount; i++)
			{
				ColumnStyle st = new ColumnStyle(SizeType.Percent, 100);
				_RdButtonsTLP.ColumnStyles.Add(st);
			}

			_NumPositionsByPage = _RdButtonsTLP.RowCount * _RdButtonsTLP.ColumnCount;
            /** 20180425. RSR */
            _StateManager.Radio.PageSize = _NumPositionsByPage;
            
            _PttBlinkList = new Dictionary<RdButton, Image>();
			_SquelchBlinkList = new Dictionary<RdButton, Image>();
			_RtxBlinkList = new Dictionary<RdButton, Color>();
            _PttPushedList = new Dictionary<RdButton, RdDst>();
 
			for (int row = 0, pos = 0; row < _RdButtonsTLP.RowCount; row++)
			{
				for (int column = 0; column < _RdButtonsTLP.ColumnCount; column++, pos++)
				{
					RdButton bt = new RdButton();
					_RdButtonsTLP.Controls.Add(bt, column, row);
					_RdButtons.Add(bt);
					_EstadosAsignacion.Add(new EstadoAsignacion());

					bt.Dock = DockStyle.Fill;
					bt.Name = "_RdButton" + pos;
					bt.Visible = false;
					bt.Id = pos;

					bt.Click += RdButton_Click;
                    bt.EnableTx(false);
                    //bt.TxClick += RdButton_TxClick;
                    bt.RxLongClick += RdButton_RxLongClick;
					bt.RxShortClick += RdButton_RxShortClick;
                    if (global::HMI.Presentation.RadioLight.Properties.Settings.Default.BigFonts)
                    {
                        this._RdButtonsTLP.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
                    }
                }
            }
            if (_StateManager.Radio.DoubleRadioSpeaker)
                if (!_StateManager.Tlf.SoloAltavoces)
                {
                    //Dos altavoces + cascos
                    // 
                    // _RdSpeakerUDB
                    // 
                    this._RdSpeakerUDB.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                    | System.Windows.Forms.AnchorStyles.Left)));
                    this._RdSpeakerUDB.BackColor = System.Drawing.Color.Transparent;
                    this._RdSpeakerUDB.DownImage = global::HMI.Presentation.RadioLight.Properties.Resources.SpeakerDown;
                    this._RdSpeakerUDB.Enabled = false;
                    this._RdSpeakerUDB.Location = new System.Drawing.Point(3, 3);
                    this._RdSpeakerUDB.Name = "_RdSpeakerUDB";
                    this._RdSpeakerUDB.Size = new System.Drawing.Size(61, 72);
                    this._RdSpeakerUDB.TabIndex = 0;
                    // 
                    // _RdHeadPhonesUDB
                    // 
                    this._RdHeadPhonesUDB.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                    | System.Windows.Forms.AnchorStyles.Left)));
                    this._RdHeadPhonesUDB.BackColor = System.Drawing.Color.Transparent;
                    this._RdHeadPhonesUDB.Enabled = false;
                    this._RdHeadPhonesUDB.Location = new System.Drawing.Point(137, 3);
                    this._RdHeadPhonesUDB.Name = "_RdHeadPhonesUDB";
                    this._RdHeadPhonesUDB.Size = new System.Drawing.Size(61, 72);
                    this._RdHeadPhonesUDB.TabIndex = 1;
                }
                else 
                {
                    //dos altavoces
                }

            // Caso por defecto, altavoz + casco opcional
            if (_StateManager.Radio.DoubleRadioSpeaker)
                if (!_StateManager.Tlf.SoloAltavoces)
                {
                    //Dos altavoces + cascos
                    // _RdSpeakerUDB más pequeño
                    this._RdSpeakerUDB.Size = new System.Drawing.Size(66, 72);

                    // _RdHfSpeakerUDB más pequeño
                    this._RdHfSpeakerUDB.Size = new System.Drawing.Size(66, 72);
                    this._RdHfSpeakerUDB.Location = new System.Drawing.Point(72, 3);

                    // _RdHeadPhonesUDB más pequeño
                    this._RdHeadPhonesUDB.Size = new System.Drawing.Size(66, 72);
                    this._RdHeadPhonesUDB.Location = new System.Drawing.Point(144, 3); 
                }
                else
                {
                    //Dos altavoces: muevo altavoz al lugar de los cascos
                    this._RdHfSpeakerUDB.Location = new System.Drawing.Point(94, 3);
                }

            _RdHfSpeakerUDB.Visible = _StateManager.Radio.DoubleRadioSpeaker;

			_RdSpeakerUDB.Level = _StateManager.RdSpeaker.Level;
			_RdSpeakerUDB.Enabled = _RdSpeakerEnabled;
            _RdSpeakerUDB.DrawX = true;
            _RdHfSpeakerUDB.Level = _StateManager.HfSpeaker.Level;
            _RdHfSpeakerUDB.Enabled = _HfSpeakerEnabled;
            _RdHfSpeakerUDB.DrawX = true;
            _RdHeadPhonesUDB.Visible = !_StateManager.Tlf.SoloAltavoces;
            _RdHeadPhonesUDB.Level = _StateManager.RdHeadPhones.Level;
			_RdHeadPhonesUDB.Enabled = _RdHeadPhonesEnabled;
			_PttBT.Enabled = _PttEnabled;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;
            _RtxBT.Text = _Rtx; // Miguel

            // Para Enaire no hay recuperación de estados de asignación
            // 26/01/2017
			// RecuperaEstadoAsignacionFrecuencias();
		}

		[EventSubscription(EventTopicNames.TftEnabledChanged, ThreadOption.Publisher)]
		[EventSubscription(EventTopicNames.EngineStateChanged, ThreadOption.Publisher)]
		public void OnTftEngineChanged(object sender, EventArgs e)
		{
			_RdSpeakerUDB.Enabled = _RdSpeakerEnabled;
            _RdHfSpeakerUDB.Enabled = _HfSpeakerEnabled;
            _RdHeadPhonesUDB.Enabled = _RdHeadPhonesEnabled;
			_PttBT.Enabled = _PttEnabled;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;

			foreach (RdButton bt in _RdButtons)
			{
				bt.Enabled = _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !_StateManager.Radio[bt.Id].Unavailable;
			}
		}

		[EventSubscription(EventTopicNames.RdSpeakerLevelChanged, ThreadOption.Publisher)]
		public void OnRdSpeakerLevelChanged(object sender, EventArgs e)
		{
			_RdSpeakerUDB.Level = _StateManager.RdSpeaker.Level;
		}

        [EventSubscription(EventTopicNames.RdHfSpeakerLevelChanged, ThreadOption.Publisher)]
        public void OnRdHFSpeakerLevelChanged(object sender, EventArgs e)
        {
            _RdHfSpeakerUDB.Level = _StateManager.HfSpeaker.Level;
        }

        [EventSubscription(EventTopicNames.RdHeadPhonesLevelChanged, ThreadOption.Publisher)]
		public void OnRdHeadPhonesLevelChanged(object sender, EventArgs e)
		{
			_RdHeadPhonesUDB.Level = _StateManager.RdHeadPhones.Level;
		}

        /* VMG 06/08/2018 */
        ///<summary>
        /// Evento producido en el cambio de estado del Ptt On/Off.
        ///</summary>
		[EventSubscription(EventTopicNames.PttOnChanged, ThreadOption.Publisher)]
		public void OnPttOnChanged(object sender, EventArgs e)
		{
            ////Control de errores para CarrierDetection y para TxConfirmation
            //if (_StateManager.Radio.PttOn)
            //{
            //    //Test
            //    if (Settings.Default.TxConfirmationDetectionTimeOut < 10)
            //        this._TxConfirmationDetectionTimer.Enabled = false;
            //    else
            //    {
            //        this._TxConfirmationDetectionTimer.Enabled = true;
            //        this._TxConfirmationDetectionTimer.Interval = Settings.Default.TxConfirmationDetectionTimeOut;
            //    }

            //    if (Settings.Default.CarrierDetectionTimeOut < 10)
            //        this._CarrierDetectionTimer.Enabled = false;
            //    else
            //    {
            //        this._CarrierDetectionTimer.Enabled = true;
            //        this._CarrierDetectionTimer.Interval = Settings.Default.CarrierDetectionTimeOut;
            //    }
            //}
            //else
            //{//Liberar del estado de error los que tengan fallo al soltar el Ptt
            //    _TxConfirmationDetectionTimer.Enabled = false;
            //    _CarrierDetectionTimer.Enabled = false;
            //    _CarrierDetectionEventFired = false;
            //    _TxErrorEventFired = false;

            //    /* VMG 04/09/2018 */
            //    //Con esto hacemos que una vez que se ha dado el error de transmision, 
            //    // al dejar de recibir PTT o dejar de pulsar el boton, se genera un estado NoPtt
            //    // que hace que el boton vuelva al estado normal seleccionado (color verde presumiblemente)
            //    var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
            //    foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
            //    {
            //        if (p.Value.Ptt != PttState.PttOnlyPort && p.Value.Ptt != PttState.PttPortAndMod
            //            && p.Value.Ptt != PttState.ExternPtt)
            //        {
            //            try
            //            {
            //                General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.NoPtt));
            //            }
            //            catch (Exception ex)
            //            {
            //                _Logger.Error("ERROR generando evento PTT.NoPtt. " + ex);
            //            }
            //        }
            //    }
            //}
            //Estados de los botones
			_PttBT.ButtonColor = _StateManager.Radio.PttOn ? VisualStyle.Colors.Blue : VisualStyle.ButtonColor;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;
		}

        [EventSubscription(EventTopicNames.SiteManagerChanged, ThreadOption.Publisher)]
        public void OnSiteManagerChanged(object sender, EventArgs e)
        {
            _SiteManagerBT.Visible = _StateManager.Radio.SiteManager;
            //_StateManager.Radio.SiteManager
            //_PttBT.ButtonColor = _StateManager.Radio.PttOn ? VisualStyle.Colors.Blue : VisualStyle.ButtonColor;
            //_RtxBT.Enabled = _RtxEnabled;
            //_RdPageBT.Enabled = _RdPageEnabled;
        }

        [EventSubscription(EventTopicNames.SiteChanged, ThreadOption.Publisher)]
        public void SiteChanged(object sender, StateMsg<string> msg)
        {
            int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

            for (int i = 0; i < _NumPositionsByPage; i++)
            {
                RdButton bt = _RdButtons[i];
                RdDst dst = _StateManager.Radio[i + absPageBegin];

                Reset(bt, dst);
            }
        }


        [EventSubscription(EventTopicNames.RtxChanged, ThreadOption.Publisher)]
		public void OnRtxChanged(object sender, EventArgs e)
		{
			if (_StateManager.Radio.Rtx > 0)
			{
				_RtxBT.Text = "Rtx " + (char)('G' + _StateManager.Radio.Rtx - 1);
				_RtxBT.ButtonColor = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;
				_RtxBlinkTimer.Enabled = true;
			}
			else
			{
				_RtxBlinkTimer.Enabled = false;
				_RtxBlinkOn = true;
				_RtxBT.Text = "Rtx";
				_RtxBT.ButtonColor = VisualStyle.ButtonColor;
			}

			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = 0; i < _NumPositionsByPage; i++)
			{
				RdButton bt = _RdButtons[i];
				RdDst dst = _StateManager.Radio[i + absPageBegin];

				Reset(bt, dst);
			}
		}

		[EventSubscription(EventTopicNames.RdPageChanged, ThreadOption.Publisher)]
		public void OnRdPageChanged(object sender, EventArgs e)
		{
			_RdPageBT.Page = _StateManager.Radio.Page;
			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = 0; i < _NumPositionsByPage; i++)
			{
				RdButton bt = _RdButtons[i];
				RdDst dst = _StateManager.Radio[i + absPageBegin];

				Reset(bt, dst);
			}
		}

		[EventSubscription(EventTopicNames.RadioChanged, ThreadOption.Publisher)]
		public void OnRadioChanged(object sender, RangeMsg e)
		{
			Debug.Assert(e.Count > 0);
			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = Math.Max(e.From, absPageBegin), to = Math.Min(e.From + e.Count, absPageBegin + _NumPositionsByPage); i < to; i++)
			{
				RdButton bt = _RdButtons[i - absPageBegin];
				RdDst dst = _StateManager.Radio[i];
				EstadoAsignacion estado = _EstadosAsignacion[i - absPageBegin];
				Reset(bt, dst, ref estado);
                /** Esta funcion se ha trasladado al MODEL MODULE */
                // Para versión Enaire no hay recuperación de estados de asignación
                // 26/01/2017
                //_EstadosAsignacion[i - absPageBegin] = estado;
                //
                //if (i < Settings.Default.AssignatedStates.Count)
                //{
                //    Settings.Default.AssignatedStates.RemoveAt(i - absPageBegin);
                //    Settings.Default.AssignatedStates.Insert(i - absPageBegin, dst.Frecuency + "," + _EstadosAsignacion[i - absPageBegin]._Rx.ToString() + "," +
                //                                        ((dst.TipoFrecuencia == 1) ? false : _EstadosAsignacion[i - absPageBegin]._Tx) +
                //                                            "," + _EstadosAsignacion[i - absPageBegin]._AudioVia + "," + _EstadosAsignacion[i - absPageBegin].Unavailable);
                //}
                //else
                //{
                //    Settings.Default.AssignatedStates.Add(dst.Frecuency + "," + _EstadosAsignacion[i - absPageBegin]._Rx.ToString() + "," +
                //                                        ((dst.TipoFrecuencia == 1) ? false : _EstadosAsignacion[i - absPageBegin]._Tx) +
                //                                            "," + _EstadosAsignacion[i - absPageBegin]._AudioVia + "," + _EstadosAsignacion[i - absPageBegin].Unavailable);
                //}
            }

            //Settings.Default.Save();
            // Fin modificación 26/01/2017

            _RtxBT.Enabled = _RtxEnabled;
		}

		[EventSubscription(EventTopicNames.TitleIdChanged, ThreadOption.Publisher)]
		public void OnTitleIdChanged(object sender, EventArgs e)
		{
			if (Settings.Default.Sector != _StateManager.Title.Id)
			{
				int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

				for (int i = absPageBegin, to = absPageBegin + _NumPositionsByPage; i < to; i++)
				{
					RdButton bt = _RdButtons[i - absPageBegin];
					if (!_StateManager.Radio[i].Unavailable && _StateManager.Radio[i].Rx)
					{
						RdButton_RxLongClick(bt, null);
					}
				}

				Settings.Default.Sector = _StateManager.Title.Id;
				Settings.Default.Save();
			}
		}

        /// <summary>
        /// Este evento llega cuando hay un cambio en la presencia del altavoz
        /// se usa para pintar el aspa en su control
        /// </summary>
        /// <param name="sender">no se usa</param>
        /// <param name="e">no se usa</param>
        [EventSubscription(EventTopicNames.SpeakerChanged, ThreadOption.Publisher)]
        public void OnSpeakerChanged(object sender, EventArgs e)
        {
            if (sender.GetType() == typeof(RdSpeaker))
            {
                if (_StateManager.RdSpeaker.Presencia == false)
                {
                    _RdSpeakerUDB.DrawX = true;
                }
                else
                {
                    _RdSpeakerUDB.DrawX = false;
                }
            }
            else if (sender.GetType() == typeof(HfSpeaker))
            {
                if (_StateManager.HfSpeaker.Presencia == false)
                {
                    _RdHfSpeakerUDB.DrawX = true;
                }
                else
                {
                    _RdHfSpeakerUDB.DrawX = false;
                }
            }
        }

        /* VMG 04/09/2018 */
        ///<summary>
        /// Error al confirmar la Transmision. Tick del Timer.
        ///</summary>
        //private void _TxConfirmationDetectionTimer_Tick(object sender, EventArgs e)
        //{
        //    try
        //    {
        //        if (_TxConfirmationDetectionTimer.Enabled)
        //        {
        //            var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
        //            foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
        //            {
        //                if (p.Value.Ptt != PttState.PttOnlyPort && p.Value.Ptt != PttState.PttPortAndMod
        //                    && p.Value.Ptt != PttState.ExternPtt)
        //                {
        //                    General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.TxError));
        //                    _TxErrorEventFired = true;
        //                }
        //            }
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _Logger.Error("ERROR generando timer error recepcion Tx", ex);
        //    }
        //}

        /* VMG 05/09/2018 */
        ///<summary>
        /// Error de Rx al realizar Tx. Tick del Timer.
        ///</summary>
        //private void _CarrierDetectionTimer_Tick(object sender, EventArgs e)
        //{
        //    try
        //    {
        //        if (_CarrierDetectionTimer.Enabled)
        //        {
        //            var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
        //            foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
        //            {
        //                if (p.Value.Ptt == PttState.PttOnlyPort && p.Value.Squelch == SquelchState.NoSquelch)
        //                {
        //                    General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.CarrierError));
        //                    _CarrierDetectionEventFired = true;
        //                }
        //            }
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _Logger.Error("ERROR generando timer Ptt", ex);
        //    }
        //}

        /** Esta funcion se ha trasladado al MODEL MODULE */
        //      private void RecuperaEstadoAsignacionFrecuencias()
        //{
        //	int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

        //	for (int i = absPageBegin, to = absPageBegin + _NumPositionsByPage; i < to; i++)
        //	{
        //		if (i < Settings.Default.AssignatedStates.Count)
        //		{
        //			string[] estado = Settings.Default.AssignatedStates[i].Split(',');

        //			EstadoAsignacion eAsignacion = new EstadoAsignacion();

        //			eAsignacion._Rx = estado[1] == "True";
        //			eAsignacion._Tx = estado[2] == "True";
        //			switch (estado[3])
        //			{
        //				case "HeadPhones":
        //					eAsignacion._AudioVia = RdRxAudioVia.HeadPhones;
        //					break;
        //				case "Speaker":
        //					eAsignacion._AudioVia = RdRxAudioVia.Speaker;
        //					break;
        //				case "NoAudio":
        //					eAsignacion._AudioVia = RdRxAudioVia.NoAudio;
        //					break;
        //			}

        //                  _EstadosAsignacion[i - absPageBegin] = eAsignacion;

        //		}
        //	}
        //}

        private void Reset(RdButton bt, RdDst dst, ref EstadoAsignacion estado)
		{
			Reset(bt, dst);

            if (!dst.Unavailable && estado.Unavailable && !_StateManager.ScreenSaver.On)
			{
				if (estado._Rx && !dst.Rx)
				{
					//RdButton_RxShortClick(bt, null);
                    Forced_RxShortClick(bt);
				}
				else if (estado._AudioVia==RdRxAudioVia.HeadPhones)
				{
                    if (dst.TipoFrecuencia == TipoFrecuencia_t.HF && (dst.AudioVia == RdRxAudioVia.HfSpeaker || dst.AudioVia == RdRxAudioVia.Speaker))
					    //RdButton_RxShortClick(bt, null);
                        Forced_RxShortClick(bt);
                    else if (dst.TipoFrecuencia != TipoFrecuencia_t.HF && dst.AudioVia == RdRxAudioVia.Speaker)
                        //RdButton_RxShortClick(bt, null);
                        Forced_RxShortClick(bt);
				}
                else if (estado._AudioVia == RdRxAudioVia.HfSpeaker && dst.AudioVia == RdRxAudioVia.Speaker)
                {
                    //RdButton_RxShortClick(bt, null);
                    Forced_RxShortClick(bt);
                }

                if (estado._Tx && !dst.Tx)
                {
                    //RdButton_TxClick(bt, null);
                    try
                    {
                        // Forzar la asignación de Tx independientemente de si está ya asignada en otra posición
                        _CmdManager.RdConfirmTxState(bt.Id);
                    }
                    catch (Exception ex)
                    {
                        int pos = _RdButtons.IndexOf(bt);
                        string msg = string.Format("ERROR modificando Tx de frecuencia RD [Pos={0}] [Id={1}]", pos, bt.Id);
                        _Logger.Error(msg, ex);
                    }
                }
			}
			else if (!dst.Unavailable && !estado.Unavailable)
			{
				estado._Tx = dst.Tx;
				estado._Rx = dst.Rx;
				estado._AudioVia = dst.AudioVia;
			}

			estado.Unavailable = dst.Unavailable ||
								estado._Rx != dst.Rx ||
								estado._Tx != dst.Tx ||
								estado._AudioVia != dst.AudioVia;
        }

		private void Reset(RdButton bt, RdDst dst)
		{
			bt.Id = dst.Id;

			if (_PttBlinkList.Remove(bt) && (_PttBlinkList.Count == 0))
			{
				_PttBlinkTimer.Enabled = false;
				_PttBlinkOn = true;
			}
			if (_SquelchBlinkList.Remove(bt) && (_SquelchBlinkList.Count == 0))
			{
				_SquelchBlinkTimer.Enabled = false;
				_SquelchBlinkOn = true;
			}
			_RtxBlinkList.Remove(bt);
            _PttPushedList.Remove(bt);

			if (dst.IsConfigurated)
			{
                Color title = VisualStyle.ButtonColor;
				Color tx = VisualStyle.ButtonColor;
				Color rx = VisualStyle.ButtonColor;
				Color txForeColor = VisualStyle.Colors.White;
				Color rxForeColor = VisualStyle.Colors.White;
                Color titleForeColor = VisualStyle.Colors.Black;
				Image ptt = null;
				Image squelch = null;
				Image audio = null;
				int rtxGroup = 0;
				bool allAsOneBt = false;
                /** 20180321. AGL. ALIAS a mostrar en la tecla... */
                // string alias = dst.Alias;
                string alias = dst.KeyAlias;

                //LALM 210223 Errores #4756 Prioridad
                int priority = dst.Priority;
				
                if (!dst.Unavailable)
				{
					rtxGroup = dst.RtxGroup;
                    // alias = (dst.TempAlias != string.Empty && dst.TempAlias != dst.Alias) ? dst.TempAlias : alias;

                    if (_StateManager.ManagingSite)
                    {
                        allAsOneBt = true;
                        title = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;
                        _RtxBlinkList[bt] = VisualStyle.Colors.Yellow;
                        //alias = (dst.TempAlias != string.Empty && dst.TempAlias != dst.Alias) ? dst.TempAlias : alias;
                    }
					else if (dst.Rx)
					{
				        rx = VisualStyle.Colors.White;
						
                        rxForeColor = VisualStyle.Colors.Green;

						if (dst.Tx)
						{
							tx = VisualStyle.Colors.White;
							txForeColor = VisualStyle.Colors.Green;
                            _PttPushedList[bt] = dst;//VMG lista con los botones seleccionados en la UI

							if (_StateManager.Radio.Rtx > 0)
							{
                                rtxGroup = dst.RtxGroup < 0 ? dst.RtxGroup : dst.TempRtxGroup;

								if (rtxGroup == 0)
								{
									allAsOneBt = true;
                                    title = _RtxBlinkOn ? VisualStyle.Colors.Yellow : bt.CurrentBackColor;
									_RtxBlinkList[bt] = VisualStyle.Colors.Yellow;
								}
								else if (rtxGroup == _StateManager.Radio.Rtx)
								{
									allAsOneBt = true;
									title = VisualStyle.Colors.Yellow;
								}
							}
						}
					}

                    NotifMsg msg = null;
                    title = VisualStyle.ButtonColor;
                    switch (dst.Ptt)
					{
                        case PttState.NoPtt:
                            break;
                        case PttState.ExternPtt:
						case PttState.PttOnlyPort:
							ptt = Resources.Ptt;
							break;
						case PttState.PttPortAndMod:
							ptt = _PttBlinkOn ? Resources.Ptt : null;
							_PttBlinkList[bt] = Resources.Ptt;
							_PttBlinkTimer.Enabled = true;
							break;
						case PttState.Blocked:
							ptt = Resources.PttBlocked;
							break;
                        //VMG 04/09/2018 Cambios en los estados
                        case PttState.Error://Error en portadora
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.CarrierDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                            General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            break;
                        //VMG 05/09/2018 Cambios en los estados
                        case PttState.CarrierError://Error en portadora
							ptt = Resources.Ptt;
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            if (!_CarrierDetectionEventFired && !_TxErrorEventFired)
                            {//Lanzamos el mensaje solo una vez
                                msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.CarrierDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                                General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            }
                            break;
                        case PttState.TxError://Error en la confirmacion de la Tx
                            // PttState.PttNotConfirmed 
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            if (!_TxErrorEventFired && !_CarrierDetectionEventFired)
                            {//Lanzamos el mensaje solo una vez
                                msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.TxConfirmationDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                                General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            }
                            break;
                        /*default://Error en la confirmacion de la Tx lo capturamos como PttState.NoPtt
                            // PttState.PttNotConfirmed 
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            NotifMsg msg2 = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.TxConfirmationDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                            General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg2);
                            break;*/
					}

					switch (dst.Squelch)
					{
						case SquelchState.SquelchOnlyPort:
							squelch = Resources.Squelch;
							break;
						case SquelchState.SquelchPortAndMod:
							squelch = _SquelchBlinkOn ? Resources.Squelch : null;
							_SquelchBlinkList[bt] = Resources.Squelch;
							_SquelchBlinkTimer.Enabled = true;
							break;
					}

					switch (dst.AudioVia)
					{
						case RdRxAudioVia.Speaker:
                            if (_StateManager.Radio.DoubleRadioSpeaker)
                                audio = Resources.SpeakerUp;
                            else
							    audio = Resources.RxSpeaker;
							break;
						case RdRxAudioVia.HeadPhones:
							audio = Resources.RxHeadPhones;
							break;
                        case RdRxAudioVia.HfSpeaker:
                            if (_StateManager.Radio.DoubleRadioSpeaker)
                                audio = Resources.HFSpeakerUp;
                            //Este caso no debería ocurrir, sólo hay un altavoz
                            //else
                            //    audio = Resources.RxSpeaker;
                            break;
                    }
				}

                // Mostrar información Qidx sólo si en HMI.exe.config está habilitado
                if (Settings.Default.ShowBssProperties)
                {
                    bt.Reset(dst.Frecuency, dst.TipoFrecuencia == TipoFrecuencia_t.FD ? dst.QidxResource : alias, dst.Unavailable, allAsOneBt, rtxGroup, ptt, squelch, audio, title, tx, rx, txForeColor, rxForeColor, titleForeColor,
                    dst.QidxResource, dst.QidxValue, dst.State);
                }
                else
                {
                    /** 20180321. AGL. ALIAS a mostrar en la tecla... */
                    // bt.Reset(dst.Frecuency, dst.TipoFrecuencia == TipoFrecuencia_t.FD ? string.Empty : alias, dst.Unavailable, allAsOneBt, rtxGroup, ptt, squelch, audio, title, tx, rx, txForeColor, rxForeColor, titleForeColor,
                    //LALM 210223  Errores #4756  prioridad
                    // Aqui Paso tambien la prioridad.
                    //bt.Reset(dst.Frecuency, alias, dst.Unavailable, allAsOneBt, rtxGroup, ptt, squelch, audio, title, tx, rx, txForeColor, rxForeColor, titleForeColor,
                    //dst.State );
                    bt.Reset(dst.Frecuency, alias, dst.Unavailable, allAsOneBt, rtxGroup, ptt, squelch, audio, title, tx, rx, txForeColor, rxForeColor, titleForeColor,
                    dst.State, dst.Priority);

                }
                // Las frecuencias co solo RX (RxOnly), tienen deshabilitada la parte TX de la tecla
                //if (dst.RxOnly)
                //    bt.EnableTx(false);
                //else
                //    bt.EnableTx(true);
                bt.Enabled = _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !dst.Unavailable;                
			}

			bt.Visible = dst.IsConfigurated;
		}

		private void _RdSpeakerUDB_LevelDown(object sender, EventArgs e)
		{
			int level = _RdSpeakerUDB.Level - 1;

			try
			{
				_CmdManager.RdSetSpeakerLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR bajando el nivel del altavoz RD a " + level, ex);
			}
		}

		private void _RdSpeakerUDB_LevelUp(object sender, EventArgs e)
		{
			int level = _RdSpeakerUDB.Level + 1;

			try
			{
				_CmdManager.RdSetSpeakerLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR subiendo el nivel del altavoz RD a " + level, ex);
			}
		}

		private void _RdHeadPhonesUDB_LevelDown(object sender, EventArgs e)
		{
			int level = _RdHeadPhonesUDB.Level - 1;

			try
			{
				_CmdManager.RdSetHeadPhonesLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR bajando el nivel de los microcascos RD a " + level, ex);
			}
		}

		private void _RdHeadPhonesUDB_LevelUp(object sender, EventArgs e)
		{
			int level = _RdHeadPhonesUDB.Level + 1;

			try
			{
				_CmdManager.RdSetHeadPhonesLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR subiendo el nivel de los microcascos RD a " + level, ex);
			}
		}

        private void _HfSpeakerUDB_LevelDown(object sender, EventArgs e)
        {
            int level = _RdHfSpeakerUDB.Level - 1;

            try
            {
                _CmdManager.RdSetHfSpeakerLevel(level);
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR bajando el nivel del altavoz HF a " + level, ex);
            }
        }

        private void _HfSpeakerUDB_LevelUp(object sender, EventArgs e)
        {
            int level = _RdHfSpeakerUDB.Level + 1;

            try
            {
                _CmdManager.RdSetHfSpeakerLevel(level);
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR subiendo el nivel del altavoz HF a " + level, ex);
            }
        }

		private void _RtxBT_Click(object sender, EventArgs e)
		{
			try
			{
				_CmdManager.RdRtxClick(_NumPositionsByPage);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR iniciando operacion Rtx", ex);
			}
		}

		private void _PttBT_MouseDown(object sender, MouseEventArgs e)
		{
			try
			{
				_CmdManager.RdSetPtt(true);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR pulsando boton de Ptt", ex);
			}
		}

		private void _PttBT_MouseUp(object sender, MouseEventArgs e)
		{
			try
			{
				_CmdManager.RdSetPtt(false);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR liberando boton de Ptt", ex);
			}
		}

		private void _RdPageBT_UpClick(object sender)
		{
			int actualPage = _RdPageBT.Page;

			try
			{
				_CmdManager.RdLoadNextPage(actualPage, _NumPositionsByPage);
			}
			catch (Exception ex)
			{
				string msg = string.Format("ERROR solicitando pagina RD siguiente [Actual={0}]", actualPage);
				_Logger.Error(msg, ex);
			}
		}

		private void _RdPageBT_DownClick(object sender)
		{
			int actualPage = _RdPageBT.Page;

			try
			{
				_CmdManager.RdLoadPrevPage(actualPage, _NumPositionsByPage);
			}
			catch (Exception ex)
			{
				string msg = string.Format("ERROR solicitando pagina RD previa [Actual={0}]", actualPage);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_Click(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
                if (_StateManager.ManagingSite)
                    _CmdManager.ChangeSite(id);
                else
                    _CmdManager.RdSwitchRtxState(id);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando pertenencia a grupo Rtx de frecuencia RD [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_TxClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchTxState(id);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Tx de frecuencia RD [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_RxLongClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchRxState(id, true);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Rx de frecuencia RD mediante pulsacion larga [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_RxShortClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchRxState(id, false);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Rx de frecuencia RD mediante pulsacion corta [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

        private void Forced_RxShortClick(object sender)
        {
            int id = ((RdButton)sender).Id;

            try
            {
                _CmdManager.RdForceRxState(id);
            }
            catch (Exception ex)
            {
                int pos = _RdButtons.IndexOf((RdButton)sender);
                string msg = string.Format("ERROR modificando Rx de frecuencia RD a partir de recuperar estado asignación [Pos={0}] [Id={1}]", pos, id);
                _Logger.Error(msg, ex);
            }
        }

        private void _SiteManagerBT_Click(object sender, EventArgs e)
        {
            try
            {
                _CmdManager.RdSiteManagerClick();
                _SiteManagerBT.ButtonColor = _StateManager.ManagingSite ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;

                int absPageBegin = _RdPageBT.Page * _NumPositionsByPage; 
                for (int i = 0; i < _NumPositionsByPage; i++)
                {
                    RdButton bt = _RdButtons[i];
                    RdDst dst = _StateManager.Radio[i + absPageBegin];

                    Reset(bt, dst);
                }
            }
            catch (Exception ex)
            {
                _Logger.Error("ERROR iniciando operacion SiteManager", ex);
            }
        }


		private void _PttBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_PttBlinkTimer.Enabled)
				{
					_PttBlinkOn = !_PttBlinkOn;
					foreach (KeyValuePair<RdButton, Image> p in _PttBlinkList)
					{
						p.Key.PttImage = _PttBlinkOn ? p.Value : null;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Ptt", ex);
			}
		}

		private void _SquelchBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_SquelchBlinkTimer.Enabled)
				{
					_SquelchBlinkOn = !_SquelchBlinkOn;
					foreach (KeyValuePair<RdButton, Image> p in _SquelchBlinkList)
					{
						p.Key.SquelchImage = _SquelchBlinkOn ? p.Value : null;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Squelch", ex);
			}
		}

		private void _RtxBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_RtxBlinkTimer.Enabled)
				{
					_RtxBlinkOn = !_RtxBlinkOn;
					_RtxBT.ButtonColor = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;

					foreach (KeyValuePair<RdButton, Color> p in _RtxBlinkList)
					{
						p.Key.TitleBackColor = _RtxBlinkOn ? p.Value : p.Key.CurrentBackColor;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Rtx", ex);
			}
		}

		private void RadioView_BackColorChanged(object sender, EventArgs e)
		{
			Invalidate(true);
		}
        /** 20190205. Pintar los errores de confirmacion de transmision */
        [EventSubscription(EventTopicNames.TxInProgressError, ThreadOption.Publisher)]
        public void OnTxInProgressError(object sender, TxInProgressErrorCode e)
        {
            var InGroupButtons = new Dictionary<RdButton, RdDst>(_PttPushedList);
            switch (e.IdEvent)
            {
                case 0:             // PTT OFF                       
                    /* VMG 04/09/2018 */                    
                    // Con esto hacemos que una vez que se ha dado el error de transmision,                                         
                    // al dejar de recibir PTT o dejar de pulsar el boton, se genera un estado NoPtt                                       
                    // que hace que el boton vuelva al estado normal seleccionado (color verde presumiblemente)
                    foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                    {
                        if (p.Value.Ptt != PttState.PttOnlyPort && p.Value.Ptt != PttState.PttPortAndMod
                            && p.Value.Ptt != PttState.ExternPtt && p.Value.Ptt != PttState.Blocked)
                        {
                            try
                            {
                                General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.NoPtt));
                            }
                            catch (Exception ex)
                            {
                                _Logger.Error("ERROR generando evento PTT.NoPtt. " + ex);
                            }
                        }
                    }
                    break;
                case 1:             // Error en Confirmacion TX.
                    {
                        foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                        {
                            if (p.Value.Ptt != PttState.PttOnlyPort &&
                                p.Value.Ptt != PttState.PttPortAndMod &&
                                p.Value.Ptt != PttState.ExternPtt &&
                                /** 20190205. Cuando esta en BLOQUEO no hay que testear el fallo de confirmacion de TX */
                                p.Value.Ptt != PttState.Blocked)
                            {
                                General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.TxError));//VMG Invented por ahora
                            }
                        }
                        NotifMsg msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.TxConfirmationDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                        General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                    }
                    break;

                case 2:             // Error en Confirmacion Portadora.
                    {
                        foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                        {
                            if (p.Value.Ptt == PttState.PttOnlyPort && p.Value.Squelch == SquelchState.NoSquelch)
                            {
                                General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.CarrierError));
                            }
                        }
                        NotifMsg msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.CarrierDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                        General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                    }
                    break;

                case 3:             // Error en Grupo RTX
                    //foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                    //{
                    //    if (p.Value.RtxGroup > 0 && p.Value.Squelch == SquelchState.NoSquelch)
                    //    {
                    //        p.Key.setRtxErrorColor(true);
                    //    }
                    //}
                    break;

                case 4:             // RTX OFF
                    //foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                    //{
                    //    if (p.Value.RtxGroup > 0 && p.Value.Squelch == SquelchState.NoSquelch)
                    //    {
                    //        p.Key.setRtxErrorColor(false);
                    //    }
                    //}
                    break;
            }
        }
    }
}

