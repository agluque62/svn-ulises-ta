//----------------------------------------------------------------------------------------
// patterns & practices - Smart Client Software Factory - Guidance Package
//
// This file was generated by the "Add View" recipe.
//
// This class is the concrete implementation of a View in the Model-View-Presenter 
// pattern. Communication between the Presenter and this class is acheived through 
// an interface to facilitate separation and testability.
// Note that the Presenter generated by the same recipe, will automatically be created
// by CAB through [CreateNew] and bidirectional references will be added.
//
// For more information see:
// ms-help://MS.VSCC.v80/MS.VSIPCC.v80/ms.practices.scsf.2007may/SCSF/html/02-09-010-ModelViewPresenter_MVP.htm
//
// Latest version of this Guidance Package: http://go.microsoft.com/fwlink/?LinkId=62182
//----------------------------------------------------------------------------------------

using System;
using System.Drawing;
using System.Diagnostics;
using System.Windows.Forms;
using System.Collections.Generic;
using Microsoft.Practices.CompositeUI;
using Microsoft.Practices.CompositeUI.SmartParts;
using Microsoft.Practices.ObjectBuilder;
using Microsoft.Practices.CompositeUI.EventBroker;
using HMI.Infrastructure.Interface;
using HMI.Model.Module.UI;
using HMI.Model.Module.Services;
using HMI.Model.Module.BusinessEntities;
using HMI.Model.Module.Messages;
using HMI.Presentation.Rabat.Constants;
using HMI.Presentation.Rabat.Properties;
using HMI.Presentation.Rabat.UI;
using Utilities;
using NLog;

namespace HMI.Presentation.Rabat.Views
{
	[SmartPart]
	public partial class RadioView : UserControl
	{
        //VMG Added events for notifying messages
        [EventPublication(EventTopicNames.RdPosPttStateEngine, PublicationScope.Global)]
        public event EventHandler<RangeMsg<PttState>> RdPosPttStateEngine;
        
        [EventPublication(EventTopicNames.ShowNotifMsgEngine, PublicationScope.Global)]
        public event EventHandler<NotifMsg> ShowNotifMsgEngine;

		struct EstadoAsignacion
		{
			public bool Unavailable;
			public bool _Tx;
			public bool _Rx;
			public RdRxAudioVia _AudioVia;
		};

		private static Logger _Logger = LogManager.GetCurrentClassLogger();

		private IModelCmdManagerService _CmdManager = null;
		private StateManagerService _StateManager = null;
		private List<RdButton> _RdButtons = new List<RdButton>();
		private Dictionary<RdButton, Image> _PttBlinkList = null;
		private Dictionary<RdButton, Image> _SquelchBlinkList = null;
		private Dictionary<RdButton, Color> _RtxBlinkList = null;
        private Dictionary<RdButton, RdDst> _PttPushedList = null;
		private bool _PttBlinkOn = true;
		private bool _SquelchBlinkOn = true;
		private bool _RtxBlinkOn = true;
		private int _NumPositionsByPage;
        private bool _CarrierDetectionEventFired = false;
        private bool _TxErrorEventFired = false;
		private List<EstadoAsignacion> _EstadosAsignacion = new List<EstadoAsignacion>();

		private bool _RdSpeakerEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative; }
		}
		private bool _RdHeadPhonesEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative; }
		}
		private bool _PttEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative; }
		}
		private bool _RtxEnabled
		{
			get
			{
				return _StateManager.Tft.Enabled && _StateManager.Engine.Operative && 
					!_StateManager.Radio.PttOn &&
					(_StateManager.Radio.GetNumFrAvalilablesForRtx(_RdPageBT.Page * _NumPositionsByPage, _NumPositionsByPage) > 1);
			}
		}
        private string _Rtx // Miguel
        {
            get { return Resources.Rtx; }
        }       
		private bool _RdPageEnabled
		{
			get { return _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !_StateManager.Radio.PttOn; }
		}

		public RadioView([ServiceDependency] IModelCmdManagerService cmdManager, [ServiceDependency] StateManagerService stateManager)
		{
			InitializeComponent();

			_CmdManager = cmdManager;
			_StateManager = stateManager;

			_RdButtonsTLP.RowCount = Settings.Default.RdRows;
			_RdButtonsTLP.RowStyles.Clear();

			for (int i = 0; i < _RdButtonsTLP.RowCount; i++)
			{
				RowStyle st = new RowStyle(SizeType.Percent, 100);
				_RdButtonsTLP.RowStyles.Add(st);
			}

			_RdButtonsTLP.ColumnCount = Settings.Default.RdColumns;
			_RdButtonsTLP.ColumnStyles.Clear();

			for (int i = 0; i < _RdButtonsTLP.ColumnCount; i++)
			{
				ColumnStyle st = new ColumnStyle(SizeType.Percent, 100);
				_RdButtonsTLP.ColumnStyles.Add(st);
			}

			_NumPositionsByPage = _RdButtonsTLP.RowCount * _RdButtonsTLP.ColumnCount;
            /** 20180425. RSR */
            _StateManager.Radio.PageSize = _NumPositionsByPage;
            
            _PttBlinkList = new Dictionary<RdButton, Image>();
			_SquelchBlinkList = new Dictionary<RdButton, Image>();
			_RtxBlinkList = new Dictionary<RdButton, Color>();
            _PttPushedList = new Dictionary<RdButton, RdDst>();
 
			for (int row = 0, pos = 0; row < _RdButtonsTLP.RowCount; row++)
			{
				for (int column = 0; column < _RdButtonsTLP.ColumnCount; column++, pos++)
				{
					RdButton bt = new RdButton();
					_RdButtonsTLP.Controls.Add(bt, column, row);
					_RdButtons.Add(bt);
					_EstadosAsignacion.Add(new EstadoAsignacion());

					bt.Dock = DockStyle.Fill;
					bt.Name = "_RdButton" + pos;
					bt.Visible = false;
					bt.Id = pos;

					bt.Click += RdButton_Click;
					bt.TxClick += RdButton_TxClick;
					bt.RxLongClick += RdButton_RxLongClick;
					bt.RxShortClick += RdButton_RxShortClick;
				}
			}

			_RdSpeakerUDB.Level = _StateManager.RdSpeaker.Level;
			_RdSpeakerUDB.Enabled = _RdSpeakerEnabled;
			_RdHeadPhonesUDB.Level = _StateManager.RdHeadPhones.Level;
			_RdHeadPhonesUDB.Enabled = _RdHeadPhonesEnabled;
			_PttBT.Enabled = _PttEnabled;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;
            _RtxBT.Text = _Rtx; // Miguel

            //RecuperaEstadoAsignacionFrecuencias();
		}

		[EventSubscription(EventTopicNames.TftEnabledChanged, ThreadOption.Publisher)]
		[EventSubscription(EventTopicNames.EngineStateChanged, ThreadOption.Publisher)]
		public void OnTftEngineChanged(object sender, EventArgs e)
		{
			_RdSpeakerUDB.Enabled = _RdSpeakerEnabled;
			_RdHeadPhonesUDB.Enabled = _RdHeadPhonesEnabled;
			_PttBT.Enabled = _PttEnabled;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;

			foreach (RdButton bt in _RdButtons)
			{
				bt.Enabled = _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !_StateManager.Radio[bt.Id].Unavailable;
			}
            //if (sender.GetType().Name == "Engine" && ((Engine)sender).Connected && ((Engine)sender).Isolated)
            //    RecuperaEstadoAsignacionFrecuencias();
		}

		[EventSubscription(EventTopicNames.RdSpeakerLevelChanged, ThreadOption.Publisher)]
		public void OnRdSpeakerLevelChanged(object sender, EventArgs e)
		{
			_RdSpeakerUDB.Level = _StateManager.RdSpeaker.Level;
		}

		[EventSubscription(EventTopicNames.RdHeadPhonesLevelChanged, ThreadOption.Publisher)]
		public void OnRdHeadPhonesLevelChanged(object sender, EventArgs e)
		{
			_RdHeadPhonesUDB.Level = _StateManager.RdHeadPhones.Level;
		}

        /* VMG 06/08/2018 */
        ///<summary>
        /// Evento producido en el cambio de estado del Ptt On/Off.
        ///</summary>
		[EventSubscription(EventTopicNames.PttOnChanged, ThreadOption.Publisher)]
		public void OnPttOnChanged(object sender, EventArgs e)
		{
            //Control de errores para CarrierDetection y para TxConfirmation
            //if (_StateManager.Radio.PttOn)
            //{
            //    if (Settings.Default.TxConfirmationDetectionTimeOut < 10)
            //        this._TxConfirmationDetectionTimer.Enabled = false;
            //    else
            //    {
            //        this._TxConfirmationDetectionTimer.Enabled = true;
            //        this._TxConfirmationDetectionTimer.Interval = Settings.Default.TxConfirmationDetectionTimeOut;
            //    }
            //    if (Settings.Default.CarrierDetectionTimeOut < 10)
            //        this._CarrierDetectionTimer.Enabled = false;
            //    else
            //    {
            //        this._CarrierDetectionTimer.Enabled = true;
            //        this._CarrierDetectionTimer.Interval = Settings.Default.CarrierDetectionTimeOut;
            //    }
            //}
            //else
            //{//Liberar del estado de error los que tengan fallo al soltar el Ptt
            //    _TxConfirmationDetectionTimer.Enabled = false;
            //    _CarrierDetectionTimer.Enabled = false;
            //    _CarrierDetectionEventFired = false;
            //    _TxErrorEventFired = false;

            //    /* VMG 04/09/2018 */
            //    //Con esto hacemos que una vez que se ha dado el error de transmision, 
            //    // al dejar de recibir PTT o dejar de pulsar el boton, se genera un estado NoPtt
            //    // que hace que el boton vuelva al estado normal seleccionado (color verde presumiblemente)
            //    var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
            //    foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
            //    {
            //        if (p.Value.Ptt != PttState.PttOnlyPort && p.Value.Ptt != PttState.PttPortAndMod
            //            && p.Value.Ptt != PttState.ExternPtt)
            //        {
            //            try
            //            {
            //                General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.NoPtt));
            //            }
            //            catch (Exception ex)
            //            {
            //                _Logger.Error("ERROR generando evento PTT.NoPtt. " + ex);
            //            }
            //        }
            //    }
            //}
			_PttBT.ButtonColor = _StateManager.Radio.PttOn ? VisualStyle.Colors.Blue : VisualStyle.ButtonColor;
			_RtxBT.Enabled = _RtxEnabled;
			_RdPageBT.Enabled = _RdPageEnabled;
		}

		[EventSubscription(EventTopicNames.RtxChanged, ThreadOption.Publisher)]
		public void OnRtxChanged(object sender, EventArgs e)
		{
			if (_StateManager.Radio.Rtx > 0)
			{
				_RtxBT.Text = "Rtx " + (char)('G' + _StateManager.Radio.Rtx - 1);
				_RtxBT.ButtonColor = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;
				_RtxBlinkTimer.Enabled = true;
			}
			else
			{
				_RtxBlinkTimer.Enabled = false;
				_RtxBlinkOn = true;
				_RtxBT.Text = "Rtx";
				_RtxBT.ButtonColor = VisualStyle.ButtonColor;
			}

			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = 0; i < _NumPositionsByPage; i++)
			{
				RdButton bt = _RdButtons[i];
				RdDst dst = _StateManager.Radio[i + absPageBegin];

				Reset(bt, dst);
			}
		}

		[EventSubscription(EventTopicNames.RdPageChanged, ThreadOption.Publisher)]
		public void OnRdPageChanged(object sender, EventArgs e)
		{
			_RdPageBT.Page = _StateManager.Radio.Page;
			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = 0; i < _NumPositionsByPage; i++)
			{
				RdButton bt = _RdButtons[i];
				RdDst dst = _StateManager.Radio[i + absPageBegin];

				//EstadoAsignacion estado = _EstadosAsignacion[i];
				//Reset(bt, dst, ref estado);
				Reset(bt, dst);
                if (i < Settings.Default.AssignatedStates.Count)
                    Settings.Default.AssignatedStates.RemoveAt(i);

                Settings.Default.AssignatedStates.Insert(i, dst.Frecuency + "," + dst.Rx.ToString() + "," + dst.Tx +
                                                            "," + dst.AudioVia + "," + dst.Unavailable);
            }

            Settings.Default.Save();
		}

		[EventSubscription(EventTopicNames.RadioChanged, ThreadOption.Publisher)]
		public void OnRadioChanged(object sender, RangeMsg e)
		{
			Debug.Assert(e.Count > 0);
			int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

			for (int i = Math.Max(e.From, absPageBegin), to = Math.Min(e.From + e.Count, absPageBegin + _NumPositionsByPage); i < to; i++)
			{
				RdButton bt = _RdButtons[i - absPageBegin];
				RdDst dst = _StateManager.Radio[i];
                /*
                if (!dst.Restored || dst.Unavailable)
                {
                    Reset(bt, dst);

                    if (!dst.Unavailable && i < Settings.Default.AssignatedStates.Count)
                    {
                        Settings.Default.AssignatedStates.RemoveAt(i - absPageBegin);
                        Settings.Default.AssignatedStates.Insert(i - absPageBegin, dst.Frecuency + "," + dst.Rx.ToString() + "," + dst.Tx +
                                                            "," + dst.AudioVia + "," + dst.Unavailable);
                    }
                    else if (!dst.Unavailable)
                    {
                        Settings.Default.AssignatedStates.Add(dst.Frecuency + "," + dst.Rx.ToString() + "," + dst.Tx +
                                                            "," + dst.AudioVia + "," + dst.Unavailable);
                    }
                    // Envío de vuelta confirmación para que Engine envíe histórico (si corresponde)
                    // De momento a este comando solo se atiende si Engine es OPE (CD30)
                    _CmdManager.SendCmdHistoricalEvent(_StateManager.Title.Id, dst.Frecuency);
                }
                else*/
                {
				    EstadoAsignacion estado = _EstadosAsignacion[i - absPageBegin];
				    Reset(bt, dst, ref estado);
				    //Reset(bt, dst);
				    _EstadosAsignacion[i - absPageBegin] = estado;

                    if (/*!dst.Unavailable &&*/ i < Settings.Default.AssignatedStates.Count)
                    {
                        Settings.Default.AssignatedStates.RemoveAt(i - absPageBegin);
                        Settings.Default.AssignatedStates.Insert(i - absPageBegin, dst.Frecuency + "," + estado._Rx.ToString() + "," + estado._Tx +
                                                            "," + dst.AudioVia + "," + dst.Unavailable);
                    }
                    else //if (!dst.Unavailable)
                    {
                        Settings.Default.AssignatedStates.Add(dst.Frecuency + "," + estado._Rx.ToString() + "," + estado._Tx +
                                                            "," + dst.AudioVia + "," + dst.Unavailable);
                    }

                    // Envío de vuelta confirmación para que Engine envíe histórico (si corresponde)
                    // De momento a este comando solo se atiende si Engine es OPE (CD30)
                    _CmdManager.SendCmdHistoricalEvent(_StateManager.Title.Id, dst.Frecuency);
                }
			}

			Settings.Default.Save();

			_RtxBT.Enabled = _RtxEnabled;
		}

		[EventSubscription(EventTopicNames.TitleIdChanged, ThreadOption.Publisher)]
		public void OnTitleIdChanged(object sender, EventArgs e)
		{
			if (Settings.Default.Sector != _StateManager.Title.Id)
			{
				int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

				for (int i = absPageBegin, to = absPageBegin + _NumPositionsByPage; i < to; i++)
				{
					RdButton bt = _RdButtons[i - absPageBegin];
					if (!_StateManager.Radio[i].Unavailable && _StateManager.Radio[i].Rx)
					{
						RdButton_RxLongClick(bt, null);
					}
				}

				Settings.Default.Sector = _StateManager.Title.Id;
				Settings.Default.Save();
			}
		}

  //      /* VMG 05/09/2018 */
  //      ///<summary>
  //      /// Error al confirmar la Transmision. Tick del Timer.
  //      ///</summary>
  //      private void _TxConfirmationDetectionTimer_Tick(object sender, EventArgs e)
  //      {
  //          try
  //          {
  //              if (_TxConfirmationDetectionTimer.Enabled)
  //              {
  //                  var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
  //                  foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
  //                  {
  //                      if (p.Value.Ptt != PttState.PttOnlyPort && p.Value.Ptt != PttState.PttPortAndMod
  //                          && p.Value.Ptt != PttState.ExternPtt)
  //                      {
  //                          General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.TxError));
  //                          _TxErrorEventFired = true;
  //                      }
  //                  }
  //              }
  //          }
  //          catch (Exception ex)
  //          {
  //              _Logger.Error("ERROR generando timer error recepcion Tx", ex);
  //          }
  //      }

  //      /* VMG 05/09/2018 */
  //      ///<summary>
  //      /// Error de Rx al realizar Tx. Tick del Timer.
  //      ///</summary>
  //      private void _CarrierDetectionTimer_Tick(object sender, EventArgs e)
  //      {
  //          try
  //          {
  //              if (_CarrierDetectionTimer.Enabled)
  //              {
  //                  var rdButtonList = new Dictionary<RdButton, RdDst>(_PttPushedList);
  //                  foreach (KeyValuePair<RdButton, RdDst> p in rdButtonList)
  //                  {
  //                      if (p.Value.Ptt == PttState.PttOnlyPort && p.Value.Squelch == SquelchState.NoSquelch)
  //                      {
  //                          General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.CarrierError));
  //                          _CarrierDetectionEventFired = true;
  //                      }
  //                  }
  //              }
  //          }
  //          catch (Exception ex)
  //          {
  //              _Logger.Error("ERROR generando timer Ptt", ex);
  //          }
  //      }
        
		//private void RecuperaEstadoAsignacionFrecuencias()
		//{
		//	int absPageBegin = _RdPageBT.Page * _NumPositionsByPage;

		//	for (int i = absPageBegin, to = absPageBegin + _NumPositionsByPage; i < to; i++)
		//	{
		//		if (i < Settings.Default.AssignatedStates.Count)
		//		{
		//			string[] estado = Settings.Default.AssignatedStates[i].Split(',');

		//			EstadoAsignacion eAsignacion = new EstadoAsignacion();

		//			eAsignacion._Rx = estado[1] == "True";
		//			eAsignacion._Tx = estado[2] == "True";
		//			switch (estado[3])
		//			{
		//				case "HeadPhones":
		//					eAsignacion._AudioVia = RdRxAudioVia.HeadPhones;
		//					break;
		//				case "Speaker":
		//					eAsignacion._AudioVia = RdRxAudioVia.Speaker;
		//					break;
		//				case "NoAudio":
		//					eAsignacion._AudioVia = RdRxAudioVia.NoAudio;
		//					break;
		//			}

		//			_EstadosAsignacion[i - absPageBegin] = eAsignacion;
		//		}
		//	}
		//}

		private void Reset(RdButton bt, RdDst dst, ref EstadoAsignacion estado)
		{
            Reset(bt, dst);

            if (!dst.Unavailable && estado.Unavailable)
            {
                if (estado._Rx && !dst.Rx)
                {
                    RdButton_RxShortClick(bt, null);
                }
                else if (estado._AudioVia == RdRxAudioVia.HeadPhones)
                {
                    if (dst.TipoFrecuencia == TipoFrecuencia_t.HF && (dst.AudioVia == RdRxAudioVia.HfSpeaker || dst.AudioVia == RdRxAudioVia.Speaker))
                        RdButton_RxShortClick(bt, null);
                    else if (dst.TipoFrecuencia != TipoFrecuencia_t.HF && dst.AudioVia == RdRxAudioVia.Speaker)
                        RdButton_RxShortClick(bt, null);
                }
                else if (estado._AudioVia == RdRxAudioVia.HfSpeaker && dst.AudioVia == RdRxAudioVia.Speaker)
                {
                    RdButton_RxShortClick(bt, null);
                }

                if (estado._Tx && !dst.Tx)
                {
                    //RdButton_TxClick(bt, null);
                    try
                    {
                        // Forzar la asignación de Tx independientemente de si está ya asignada en otra posición
                        _CmdManager.RdConfirmTxState(bt.Id);
                    }
                    catch (Exception ex)
                    {
                        int pos = _RdButtons.IndexOf(bt);
                        string msg = string.Format("ERROR modificando Tx de frecuencia RD [Pos={0}] [Id={1}]", pos, bt.Id);
                        _Logger.Error(msg, ex);
                    }
                }
            }
            else if (!dst.Unavailable && !estado.Unavailable)
            {
                estado._Tx = dst.Tx;
                estado._Rx = dst.Rx;
                estado._AudioVia = dst.AudioVia;
            }

            estado.Unavailable = dst.Unavailable ||
                                estado._Rx != dst.Rx ||
                                estado._Tx != dst.Tx ||
                                estado._AudioVia != dst.AudioVia;
        }

		private void Reset(RdButton bt, RdDst dst)
		{
			bt.Id = dst.Id;

			if (_PttBlinkList.Remove(bt) && (_PttBlinkList.Count == 0))
			{
				_PttBlinkTimer.Enabled = false;
				_PttBlinkOn = true;
			}
			if (_SquelchBlinkList.Remove(bt) && (_SquelchBlinkList.Count == 0))
			{
				_SquelchBlinkTimer.Enabled = false;
				_SquelchBlinkOn = true;
			}
			_RtxBlinkList.Remove(bt);
            _PttPushedList.Remove(bt);

			if (dst.IsConfigurated)
			{
				Color title = VisualStyle.ButtonColor;
				Color tx = VisualStyle.ButtonColor;
				Color rx = VisualStyle.ButtonColor;
				Color txForeColor = VisualStyle.Colors.White;
				Color rxForeColor = VisualStyle.Colors.White;
				Image ptt = null;
				Image squelch = null;
				Image audio = null;
				int rtxGroup = 0;
				bool allAsOneBt = false;

				if (!dst.Unavailable)
				{
					rtxGroup = dst.RtxGroup;

					if (dst.Rx)
					{
						title = rx = VisualStyle.Colors.White;
						rxForeColor = VisualStyle.Colors.Green;

						if (dst.Tx)
						{
							tx = VisualStyle.Colors.White;
							txForeColor = VisualStyle.Colors.Green;
                            _PttPushedList[bt] = dst;//VMG lista con los botones seleccionados en la UI

							if (_StateManager.Radio.Rtx > 0)
							{
								rtxGroup = dst.TempRtxGroup;

								if (rtxGroup == 0)
								{
									allAsOneBt = true;
									title = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;
									_RtxBlinkList[bt] = VisualStyle.Colors.Yellow;
								}
								else if (rtxGroup == _StateManager.Radio.Rtx)
								{
									allAsOneBt = true;
									title = VisualStyle.Colors.Yellow;
								}
							}
						}
					}

                    NotifMsg msg = null;
					switch (dst.Ptt)
					{
                        case PttState.NoPtt:
                            break;
						case PttState.ExternPtt:
						case PttState.PttOnlyPort:
							ptt = Resources.Ptt;
							break;
						case PttState.PttPortAndMod:
							ptt = _PttBlinkOn ? Resources.Ptt : null;
							_PttBlinkList[bt] = Resources.Ptt;
							_PttBlinkTimer.Enabled = true;
							break;
						case PttState.Blocked:
							ptt = Resources.PttBlocked;
							break;
                        //VMG 04/09/2018 Cambios en los estados
                        case PttState.Error://Error en portadora
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.CarrierDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                            General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            break;
                        //VMG 05/09/2018 Cambios en los estados
                        case PttState.CarrierError://Error en portadora
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            if (!_CarrierDetectionEventFired && !_TxErrorEventFired)
                            {//Lanzamos el mensaje solo una vez
                                msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.CarrierDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                                General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            }
                            break;
                        case PttState.TxError://Error en la confirmacion de la Tx
                            // PttState.PttNotConfirmed 
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            if (!_TxErrorEventFired && !_CarrierDetectionEventFired)
                            {//Lanzamos el mensaje solo una vez
                                msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.TxConfirmationDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                                General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                            }
                            break;
                        /*default://Error en la confirmacion de la Tx lo capturamos como PttState.NoPtt
                            // PttState.PttNotConfirmed 
                            title = VisualStyle.Colors.Red;
                            txForeColor = VisualStyle.Colors.Red;
                            NotifMsg msg2 = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.TxConfirmationDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                            General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg2);
                            break;*/
					}

					switch (dst.Squelch)
					{
						case SquelchState.SquelchOnlyPort:
							squelch = Resources.Squelch;
							break;
						case SquelchState.SquelchPortAndMod:
							squelch = _SquelchBlinkOn ? Resources.Squelch : null;
							_SquelchBlinkList[bt] = Resources.Squelch;
							_SquelchBlinkTimer.Enabled = true;
							break;
					}

					switch (dst.AudioVia)
					{
                        case RdRxAudioVia.NoAudio:
                            if (dst.Monitoring)
                                audio = Resources.RxNoDesasignable;
                            break;
						case RdRxAudioVia.Speaker:
							audio = dst.Monitoring ? Resources.RxNoDesasignable : Resources.RxSpeaker;
							break;
						case RdRxAudioVia.HeadPhones:
							audio = Resources.RxHeadPhones;
							break;
					}
				}

                bt.Reset(dst.Frecuency, dst.Alias, dst.Unavailable, allAsOneBt, rtxGroup, ptt, squelch, audio, title, tx, rx, txForeColor, rxForeColor,VisualStyle.Colors.Black);
				bt.Enabled = _StateManager.Tft.Enabled && _StateManager.Engine.Operative && !dst.Unavailable;
			}

			bt.Visible = dst.IsConfigurated;
		}

		private void _RdSpeakerUDB_LevelDown(object sender, EventArgs e)
		{
			int level = _RdSpeakerUDB.Level - 1;

			try
			{
				_CmdManager.RdSetSpeakerLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR bajando el nivel del altavoz RD a " + level, ex);
			}
		}

		private void _RdSpeakerUDB_LevelUp(object sender, EventArgs e)
		{
			int level = _RdSpeakerUDB.Level + 1;

			try
			{
				_CmdManager.RdSetSpeakerLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR subiendo el nivel del altavoz RD a " + level, ex);
			}
		}

		private void _RdHeadPhonesUDB_LevelDown(object sender, EventArgs e)
		{
			int level = _RdHeadPhonesUDB.Level - 1;

			try
			{
				_CmdManager.RdSetHeadPhonesLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR bajando el nivel de los microcascos RD a " + level, ex);
			}
		}

		private void _RdHeadPhonesUDB_LevelUp(object sender, EventArgs e)
		{
			int level = _RdHeadPhonesUDB.Level + 1;

			try
			{
				_CmdManager.RdSetHeadPhonesLevel(level);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR subiendo el nivel de los microcascos RD a " + level, ex);
			}
		}

		private void _RtxBT_Click(object sender, EventArgs e)
		{
			try
			{
				_CmdManager.RdRtxClick(_NumPositionsByPage);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR iniciando operacion Rtx", ex);
			}
		}

		private void _PttBT_MouseDown(object sender, MouseEventArgs e)
		{
			try
			{
				_CmdManager.RdSetPtt(true);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR pulsando boton de Ptt", ex);
			}
		}

		private void _PttBT_MouseUp(object sender, MouseEventArgs e)
		{
			try
			{
				_CmdManager.RdSetPtt(false);
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR liberando boton de Ptt", ex);
			}
		}

		private void _RdPageBT_UpClick(object sender)
		{
			int actualPage = _RdPageBT.Page;

			try
			{
				_CmdManager.RdLoadNextPage(actualPage, _NumPositionsByPage);
			}
			catch (Exception ex)
			{
				string msg = string.Format("ERROR solicitando pagina RD siguiente [Actual={0}]", actualPage);
				_Logger.Error(msg, ex);
			}
		}

		private void _RdPageBT_DownClick(object sender)
		{
			int actualPage = _RdPageBT.Page;

			try
			{
				_CmdManager.RdLoadPrevPage(actualPage, _NumPositionsByPage);
			}
			catch (Exception ex)
			{
				string msg = string.Format("ERROR solicitando pagina RD previa [Actual={0}]", actualPage);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_Click(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchRtxState(id);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando pertenencia a grupo Rtx de frecuencia RD [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_TxClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchTxState(id);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Tx de frecuencia RD [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_RxLongClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchRxState(id, true);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Rx de frecuencia RD mediante pulsacion larga [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void RdButton_RxShortClick(object sender, EventArgs e)
		{
			int id = ((RdButton)sender).Id;

			try
			{
				_CmdManager.RdSwitchRxState(id, false);
			}
			catch (Exception ex)
			{
				int pos = _RdButtons.IndexOf((RdButton)sender);
				string msg = string.Format("ERROR modificando Rx de frecuencia RD mediante pulsacion corta [Pos={0}] [Id={1}]", pos, id);
				_Logger.Error(msg, ex);
			}
		}

		private void _PttBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_PttBlinkTimer.Enabled)
				{
					_PttBlinkOn = !_PttBlinkOn;
					foreach (KeyValuePair<RdButton, Image> p in _PttBlinkList)
					{
						p.Key.PttImage = _PttBlinkOn ? p.Value : null;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Ptt", ex);
			}
		}

		private void _SquelchBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_SquelchBlinkTimer.Enabled)
				{
					_SquelchBlinkOn = !_SquelchBlinkOn;
					foreach (KeyValuePair<RdButton, Image> p in _SquelchBlinkList)
					{
						p.Key.SquelchImage = _SquelchBlinkOn ? p.Value : null;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Squelch", ex);
			}
		}

		private void _RtxBlinkTimer_Tick(object sender, EventArgs e)
		{
			try
			{
				if (_RtxBlinkTimer.Enabled)
				{
					_RtxBlinkOn = !_RtxBlinkOn;
					_RtxBT.ButtonColor = _RtxBlinkOn ? VisualStyle.Colors.Yellow : VisualStyle.ButtonColor;

					foreach (KeyValuePair<RdButton, Color> p in _RtxBlinkList)
					{
						p.Key.TitleBackColor = _RtxBlinkOn ? p.Value : VisualStyle.ButtonColor;
					}
				}
			}
			catch (Exception ex)
			{
				_Logger.Error("ERROR generando parpadeo de Rtx", ex);
			}
		}

		private void RadioView_BackColorChanged(object sender, EventArgs e)
		{
			Invalidate(true);
		}
        /** 20190205. Pintar los errores de confirmacion de transmision */
        [EventSubscription(EventTopicNames.TxInProgressError, ThreadOption.Publisher)]
        public void OnTxInProgressError(object sender, TxInProgressErrorCode e)
        {
            var InGroupButtons = new Dictionary<RdButton, RdDst>(_PttPushedList);
            switch (e.IdEvent)
            {
                case 0:             // PTT OFF                       
                                    /* VMG 04/09/2018 */
                                    // Con esto hacemos que una vez que se ha dado el error de transmision,                                         
                                    // al dejar de recibir PTT o dejar de pulsar el boton, se genera un estado NoPtt                                       
                                    // que hace que el boton vuelva al estado normal seleccionado (color verde presumiblemente)
                    foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                    {
                        if (p.Value.Ptt != PttState.PttOnlyPort && p.Value.Ptt != PttState.PttPortAndMod
                            && p.Value.Ptt != PttState.ExternPtt && p.Value.Ptt != PttState.Blocked)
                        {
                            try
                            {
                                General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.NoPtt));
                            }
                            catch (Exception ex)
                            {
                                _Logger.Error("ERROR generando evento PTT.NoPtt. " + ex);
                            }
                        }
                    }
                    break;
                case 1:             // Error en Confirmacion TX.
                    {
                        foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                        {
                            if (p.Value.Ptt != PttState.PttOnlyPort &&
                                p.Value.Ptt != PttState.PttPortAndMod &&
                                p.Value.Ptt != PttState.ExternPtt &&
                                /** 20190205. Cuando esta en BLOQUEO no hay que testear el fallo de confirmacion de TX */
                                p.Value.Ptt != PttState.Blocked)
                            {
                                General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.TxError));//VMG Invented por ahora
                            }
                        }
                        NotifMsg msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.TxConfirmationDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                        General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                    }
                    break;

                case 2:             // Error en Confirmacion Portadora.
                    {
                        foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                        {
                            if (p.Value.Ptt == PttState.PttOnlyPort && p.Value.Squelch == SquelchState.NoSquelch)
                            {
                                General.SafeLaunchEvent(RdPosPttStateEngine, this, new RangeMsg<PttState>(p.Key.Id, PttState.CarrierError));
                            }
                        }
                        NotifMsg msg = new NotifMsg("Bad Operation", Resources.BadOperation, Resources.CarrierDetectionError, 3000, MessageType.Error, MessageButtons.Ok);
                        General.SafeLaunchEvent(ShowNotifMsgEngine, this, msg);
                    }
                    break;

                case 3:             // Error en Grupo RTX
                    //foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                    //{
                    //    if (p.Value.RtxGroup > 0 && p.Value.Squelch == SquelchState.NoSquelch)
                    //    {
                    //        p.Key.setRtxErrorColor(true);
                    //    }
                    //}
                    break;

                case 4:             // RTX OFF
                    //foreach (KeyValuePair<RdButton, RdDst> p in InGroupButtons)
                    //{
                    //    if (p.Value.RtxGroup > 0 && p.Value.Squelch == SquelchState.NoSquelch)
                    //    {
                    //        p.Key.setRtxErrorColor(false);
                    //    }
                    //}
                    break;
            }
        }
    }
}

